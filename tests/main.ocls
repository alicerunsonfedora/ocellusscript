#
# Ocellus
# A Haskell-inspired functional programming language
# (C) 2020 Marquis Kurt. All rights reserved.
# 

# Premise: Ocellus is a functional programming language designed to work hand-in-hand with 
# Unscripted and its minigame. It mainly takes inspiration from Haskell, Swift, ES5, and Python.
# Ocellus aims to be easy to use and understand while powerful enough to make task automation
# easier. Ocellus include features like pattern matching, optional types, ternary operators, 
# and docstrings.

import Main

module Sample where

# Section 1: Variable Storage
# As this is meant to be functional, we're really making functions
# that return these values.

helloWorld takes Nothing returns String     # Type signature
`Give a simple Hello, world!`               # Docstring
helloWorld = "Hello, world!"                # Function def.

quickMaths takes Nothing returns Integer
`Show simple mathematical operations in a func.`
quickMaths = 1 + 2

testBool takes Nothing returns Boolean
`Store the false value`
testBool = false

# Section 2: Functions with Parameters

square takes Integer returns Integer
`Take an integer and multiply it by itself.

Arguments:
    x: The number to square.
`
square x = x * x

reverse takes String returns String
`Reverses the string.

Arguments:
    x: The string to reverse.
`
reverse x = helper x "" where
            helper "" string = string
            helper x string = string + x
            helper x:xs string = helper xs (string + x)

testNothing takes Integer returns Boolean?
`Stores an optional boolean value when assigned 0.`
testNothing 0 = true
testNothing x = Nothing

# Section 3: Higher-order Functions
# The following are Ocellus-implemented variations of the common map, filter, and reduce
# functions.

map takes (Callable takes Anything returns Anything) and [Anything] returns [Anything]
`Generate a list with an applied function.

Arguments:
    func: The function to run over every item in the list
    x: The list to run the function on its items
`
map func x = helper func x [] where
                helper func [] list = list
                helper func i list = list + [func i]
                helper func (i:j) list = helper func j (list + [func i])

filter takes (Callable takes Anything returns Boolean) and [Anything] returns [Anything]
`Generate a list given a condition and an existing list.

Arguments:
    f: The function to mark items as true or false
    x: The list to run the function on its items
`
filter f x = helper f x [] where
                helper func [] list = list
                helper func i list = list + (func i) 
                                            ? [(func i)] 
                                            : []
                helper func (i:j) list = helper func j (list + (func i) 
                                                        ? [(func i)] 
                                                        : [])

reduce takes (Callable takes Anything and Anything returns Anything) and [Anything] and Anything \ 
    returns Anything
`Generate a single value from a list with a method of combination.

Arguments:
    f: The function to combine values
    x: The list to reduce to a single value
    s: The starting value
`
reduce f x s = helper f x s where
                helper combinator [] s = s
                helper combinator i s = combinator i s
                helper combinator (i:j) s = helper combinator j (combinator i s)


# Section 4: Optional Values
# Ocellus should be able to support optional values where something could be stored as a specific 
# type or as Nothing.

health takes Integer? returns Integer
`Assign the current health. If no value is provided, 100 is used.

Arguments:
    default: The value to set the health to. Optional.
`
health value = value ?? 100


takeDamage takes Integer and Integer? returns Integer
`Subtract a health amount, either randomly or by a set amount.

Arguments:
    curr: The current health to subtract from.
    by: The health to subtract by, if any. Optional.
`
takeDamage curr by = helper curr by where
                        helper h Nothing = h - (randInt 1 5)
                        helper h a = h - a

# This is here to demonstrate the following 'ohYeah' function.
expressions takes Nothing returns [String]
expressions = ["Oh", "Ooh", "Sure", Nothing]

ohYeah takes [Anything?] returns [String]
`Apply a 'yeah' to each string.

Arguments:
    list: The list of expressions to add 'yeah' to
`
ohYeah list = map (lambda a -> a ? ", yeah!" : "Yeah!") list

# Section 5: Loops and Recursion
# Ocellus supports traditional recursion and for loops. Sort of.

# These functions are predefined for the following getLifePathNumber
# function.

lastDigit takes Integer returns Integer
`Get the last digit of a number.`
lastDigit num = num % 10

butLastDigit takes Integer returns Integer
`Get everything but the last digit of the number.`
butLastDigit num = num / 10

getDigitSum takes Integer returns Integer
`Gets the sum of the digits of a number.

Arguments:
    number: The number to get the digit sum of.
`
getDigitSum number = helper number 0 where
                        helper num result = number == 0 
                            ? result
                            : helper (butLastDigit num) (result + (lastDigit num)) 

getLifePathNumber takes (Integer, Integer, Integer) returns Integer
`Gets the life path number by adding the digits of a tuple with
a birthdate.

Arguments:
    birthdate: The birthdate to get the life path number of
`
getLifePathNumber month, day, year = getDigitSum ((getDigitSum month) +
                                                  (getDigitSum day) +
                                                  (getDigitSum year))

# Alternatively, for loops can be used, somewhat. These loops are more oriented towards
# ranges and thus will take care of any value increments.

# The following is the implementation of the "for" expression.
for takes Anything and Anything and (Callable takes Anything? returns Anything?) returns Nothing
`Iterate over a range and perform a task at each step.

Arguments:
    start: The starting value.
    end: The ending value.
    task: The task to perform.
`
for start end task = forHelper start start end task where
                        forHelper i n j t = j == n
                                            ? t
                                            : forHelper (i + 1) n (j - 1) t

# This list containing the names of villains is hidden, so this will not be visible when
# importing this module into another file.
private villains = ["AEGIS", "Gargamel", "Chrysalis"]

warnOfVillains takes [String] returns Nothing
warnOfVillains list = for 0 range ((length list) - 1) task where
                        task i = member list[i] villains
                            ? warn (list[i] + " is a villain!")
                            : log "Safe!"

countToTen takes Nothing returns Nothing
countToTen = for i, range 10, task where
                task = log i

# Section 6: Data Types and Trees

# Custom types can be defined as if the base types are functions.
type Side = Float
type Radius = Float

# Data types can be defined as types of types in this manner.
datatype Shape = Rectangle Side Side 
                    or Ellipse Radius Radius

# Functions can make use of custom types.
area takes Shape returns Float
`Get the area of a Shape

Arguments:
    shape: The shape to get the area of.
`
area shape = helper shape where
                area (Rectangle x y) = x * y
                area (Ellipse r q) = r1 * r2 * pi

# The result of a data type can be used in a function as well.
squareFactory takes Side returns Shape
`Generate a Rectangle shape with equal width and height.`
squareFactory side = Rectangle side side

# Likewise, this can be used to generate trees.

datatype IntegerTree = IntegerBranch IntegerNode? IntegerTree IntegerTree 
                        or IntegerLeaf Integer?

addlapseTree takes IntegerTree returns Integer
`Traverses the IntegerTree and adds up all of the values.

Any values that are Nothing will be substituted with 0.

Arguments:
    tree: The tree to traverse.
`
addlapseTree tree = collapseHelper tree where
                        collapseHelper (IntegerLeaf i) = i ? i : 0
                        collapseHelper (IntegerBranch value t1 t2) = (value ? value: 0)
                                                                        + (collapseHelper t1)
                                                                        + (collapseHelper t2)