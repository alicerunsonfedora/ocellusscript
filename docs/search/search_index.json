{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OcellusScript \u00b6 A Haskell-inspired functional programming language \u00b6 OcellusScript is a simple functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel . It heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language. Quick start \u00b6 To get started with writing OcellusScript code, install the Efficacy tools using pip: pip install efficacy To try compiling an example, download an example file and run the compiler: efficacy -i <filename>.ocls -o example Other tools \u00b6 Visual Studio Code extension","title":"OcellusScript"},{"location":"#ocellusscript","text":"","title":"OcellusScript"},{"location":"#a-haskell-inspired-functional-programming-language","text":"OcellusScript is a simple functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel . It heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language.","title":"A Haskell-inspired functional programming language"},{"location":"#quick-start","text":"To get started with writing OcellusScript code, install the Efficacy tools using pip: pip install efficacy To try compiling an example, download an example file and run the compiler: efficacy -i <filename>.ocls -o example","title":"Quick start"},{"location":"#other-tools","text":"Visual Studio Code extension","title":"Other tools"},{"location":"vscode/","text":"VS Code Extension \u00b6 The OcellusScript extension for Visual Studio code offers syntax highlighting support for OcellusScript files and includes snippets for writing pieces of code faster. Getting started \u00b6 To add this extension to your Visual Studio Code installation, search for it in the Visual Studio Marketplace and install the extension. Alternatively, you can clone the GitHub repository and install the extension to your extensions folder: git clone https://github.com/alicerunsonfedora/ocellusscript-vscode ~/.vscode/extensions/net.marquiskurt.ocellusscript-lang Snippets \u00b6 The following snippets are available out-of-the-box when installing this extension: mapf : Writes out the map higher-order function . filterf : Writes out the filter higher-order function . reducef : Writes out the map higher-order function . forf : Writes out the for higher-order function . lmbd : Writes out a boilerplate lambda expression . ifcond : Writes out a boilerplate for a conditional expression . mname : Writes out a boilerplate for a module declaration . dtype : Writes out a boilerplate for a datatype declaration .","title":"VS Code Extension"},{"location":"vscode/#vs-code-extension","text":"The OcellusScript extension for Visual Studio code offers syntax highlighting support for OcellusScript files and includes snippets for writing pieces of code faster.","title":"VS Code Extension"},{"location":"vscode/#getting-started","text":"To add this extension to your Visual Studio Code installation, search for it in the Visual Studio Marketplace and install the extension. Alternatively, you can clone the GitHub repository and install the extension to your extensions folder: git clone https://github.com/alicerunsonfedora/ocellusscript-vscode ~/.vscode/extensions/net.marquiskurt.ocellusscript-lang","title":"Getting started"},{"location":"vscode/#snippets","text":"The following snippets are available out-of-the-box when installing this extension: mapf : Writes out the map higher-order function . filterf : Writes out the filter higher-order function . reducef : Writes out the map higher-order function . forf : Writes out the for higher-order function . lmbd : Writes out a boilerplate lambda expression . ifcond : Writes out a boilerplate for a conditional expression . mname : Writes out a boilerplate for a module declaration . dtype : Writes out a boilerplate for a datatype declaration .","title":"Snippets"},{"location":"efficacy/","text":"About Efficacy \u00b6 Efficacy is the official lexer, parser, compiler, and interactive interpreter for the OcellusScript language. Efficacy can be installed as a command-line program or can be imported into Python scripts as a Python module. Efficacy currently supports Python 2.7.16 and Python 3.7+. Warning It is highly recommended that you do not use Efficacy with Python 2.7. Support for 2.7 is included only for projects that cannot be upgraded to Python 3 and is only a compatibility solution. Getting Started \u00b6 Efficacy can be installed in a Python environment using pip: pip install efficacy Alternatively, Efficacy can be added as a dependency to a Poetry project: poetry add efficacy; poetry update","title":"About Efficacy"},{"location":"efficacy/#about-efficacy","text":"Efficacy is the official lexer, parser, compiler, and interactive interpreter for the OcellusScript language. Efficacy can be installed as a command-line program or can be imported into Python scripts as a Python module. Efficacy currently supports Python 2.7.16 and Python 3.7+. Warning It is highly recommended that you do not use Efficacy with Python 2.7. Support for 2.7 is included only for projects that cannot be upgraded to Python 3 and is only a compatibility solution.","title":"About Efficacy"},{"location":"efficacy/#getting-started","text":"Efficacy can be installed in a Python environment using pip: pip install efficacy Alternatively, Efficacy can be added as a dependency to a Poetry project: poetry add efficacy; poetry update","title":"Getting Started"},{"location":"efficacy/01-cli/","text":"Using Efficacy CLI \u00b6 The Efficacy compiler and interactive environment can be called from the terminal by running efficacy. Arguments \u00b6 The following are arguments that can be passed to Efficacy to specify details. Running Efficacy without any arguments opens the interactive mode. Argument Full Argument Required Description -i --input No* The path to the input file to compile -o --output No The path to where the compiled executable will be placed -oT --output-tokens No The path to where the token file will be placed *This argument is required only if you're compiling files. Creating a Token File \u00b6 Efficacy supports creating a JSON file containing the tokens it discovered while tokenizing the input file. It mainly contains a list of objects with the token type (see Lexical Elements ) and the token itself: [ { \"Identifier\" : \"x\" }, { \"Symbol\" : \"=\" }, { \"Identifier\" : \"x\" }, { \"Symbol\" : \"+\" }, { \"IntConstant\" : \"5\" }, ] This token file is useful when comparing a lexer's ability to tokenize an OcellusScript file to Efficacy's lexer, OSTokenizer .","title":"Using Efficacy CLI"},{"location":"efficacy/01-cli/#using-efficacy-cli","text":"The Efficacy compiler and interactive environment can be called from the terminal by running efficacy.","title":"Using Efficacy CLI"},{"location":"efficacy/01-cli/#arguments","text":"The following are arguments that can be passed to Efficacy to specify details. Running Efficacy without any arguments opens the interactive mode. Argument Full Argument Required Description -i --input No* The path to the input file to compile -o --output No The path to where the compiled executable will be placed -oT --output-tokens No The path to where the token file will be placed *This argument is required only if you're compiling files.","title":"Arguments"},{"location":"efficacy/01-cli/#creating-a-token-file","text":"Efficacy supports creating a JSON file containing the tokens it discovered while tokenizing the input file. It mainly contains a list of objects with the token type (see Lexical Elements ) and the token itself: [ { \"Identifier\" : \"x\" }, { \"Symbol\" : \"=\" }, { \"Identifier\" : \"x\" }, { \"Symbol\" : \"+\" }, { \"IntConstant\" : \"5\" }, ] This token file is useful when comparing a lexer's ability to tokenize an OcellusScript file to Efficacy's lexer, OSTokenizer .","title":"Creating a Token File"},{"location":"efficacy/module/","text":"Usage \u00b6 Efficacy can be used in Python scripts and projects as an importable module. The following documentation covers all of the publicly-facing APIs and utilities available in the Efficacy package. Modules \u00b6 CLI Lexer","title":"Usage"},{"location":"efficacy/module/#usage","text":"Efficacy can be used in Python scripts and projects as an importable module. The following documentation covers all of the publicly-facing APIs and utilities available in the Efficacy package.","title":"Usage"},{"location":"efficacy/module/#modules","text":"CLI Lexer","title":"Modules"},{"location":"efficacy/module/00-cli/","text":"CLI \u00b6 The cli submodule of Efficacy contains the source code and functionality for the command-line application version of the Efficacy compiler. run_cli \u00b6 Start the main process for the CLI application. Arguments with_args : (Optional) The arguments to run the CLI with. Will default to sys.argv if no arguments have been supplied. Example Below is an example of how the CLI can be called programmatically using run_cli() . from efficacy.cli import run_cli from subproccess import check_call print ( check_call ( run_cli ([ \"-i\" , \"main.ocls\" , \"-oT\" , \"tokens.json\" ])))","title":"CLI"},{"location":"efficacy/module/00-cli/#cli","text":"The cli submodule of Efficacy contains the source code and functionality for the command-line application version of the Efficacy compiler.","title":"CLI"},{"location":"efficacy/module/00-cli/#run_cli","text":"Start the main process for the CLI application. Arguments with_args : (Optional) The arguments to run the CLI with. Will default to sys.argv if no arguments have been supplied. Example Below is an example of how the CLI can be called programmatically using run_cli() . from efficacy.cli import run_cli from subproccess import check_call print ( check_call ( run_cli ([ \"-i\" , \"main.ocls\" , \"-oT\" , \"tokens.json\" ])))","title":"run_cli"},{"location":"efficacy/module/01-lexer/","text":"Lexer \u00b6 The lexer submodule of Efficacy contains all of the tools necessary to tokenize a string or a file into a a list of OcellusScript tokens. OSTokenType \u00b6 An enumeration type for the different token types. This enumeration class is used to differentiate between the different types of tokens used for OcellusScript parsing. The values of the enumerations correspond to the lexical grammar names for each type. Key Corresponding Value keyword Keyword identifier Identifier string StringConstant docstring DocstringConstant comment CommentConstant symbol Symbol num_integer IntConstant num_float FloatConstant operator Operator OSTokenizer \u00b6 The tokenizing class for OcellusScript. The tokenizer is responsible for converting a stream of characters into OcellusScript tokens that can be used for parsing. Example Below is an example of how OSTokenizer can be used to create a list of tokens from a string containing OcellusScript code. from efficacy.lexer import OSTokenizer lexer = OSTokenizer ( script = \"example x = x > 5 ? x + 6 : x + 8 \\n \" ) tokens = lexer . tokenize () print ( tokens [ 0 ]) # (<OSTokenType: OSTokenType.identifier>, \"example\") Attributes \u00b6 source : The list of characters that will be converted to tokens Methods \u00b6 __init__ \u00b6 Initialize the tokenizer. Arguments script : The script string to tokenize tokenize \u00b6 Generate a list of tokens from a given string. Returns : A list containing the tokens as a tuple containing the token's type and the token itself.","title":"Lexer"},{"location":"efficacy/module/01-lexer/#lexer","text":"The lexer submodule of Efficacy contains all of the tools necessary to tokenize a string or a file into a a list of OcellusScript tokens.","title":"Lexer"},{"location":"efficacy/module/01-lexer/#ostokentype","text":"An enumeration type for the different token types. This enumeration class is used to differentiate between the different types of tokens used for OcellusScript parsing. The values of the enumerations correspond to the lexical grammar names for each type. Key Corresponding Value keyword Keyword identifier Identifier string StringConstant docstring DocstringConstant comment CommentConstant symbol Symbol num_integer IntConstant num_float FloatConstant operator Operator","title":"OSTokenType"},{"location":"efficacy/module/01-lexer/#ostokenizer","text":"The tokenizing class for OcellusScript. The tokenizer is responsible for converting a stream of characters into OcellusScript tokens that can be used for parsing. Example Below is an example of how OSTokenizer can be used to create a list of tokens from a string containing OcellusScript code. from efficacy.lexer import OSTokenizer lexer = OSTokenizer ( script = \"example x = x > 5 ? x + 6 : x + 8 \\n \" ) tokens = lexer . tokenize () print ( tokens [ 0 ]) # (<OSTokenType: OSTokenType.identifier>, \"example\")","title":"OSTokenizer"},{"location":"efficacy/module/01-lexer/#attributes","text":"source : The list of characters that will be converted to tokens","title":"Attributes"},{"location":"efficacy/module/01-lexer/#methods","text":"","title":"Methods"},{"location":"efficacy/module/01-lexer/#__init__","text":"Initialize the tokenizer. Arguments script : The script string to tokenize","title":"__init__"},{"location":"efficacy/module/01-lexer/#tokenize","text":"Generate a list of tokens from a given string. Returns : A list containing the tokens as a tuple containing the token's type and the token itself.","title":"tokenize"},{"location":"language/","text":"Welcome \u00b6 The following documentation will guide you through learning the general syntax and nature of OcellusScript. What is OcellusScript? \u00b6 OcellusScript is a functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel. OcellusScript heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language.","title":"Welcome"},{"location":"language/#welcome","text":"The following documentation will guide you through learning the general syntax and nature of OcellusScript.","title":"Welcome"},{"location":"language/#what-is-ocellusscript","text":"OcellusScript is a functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel. OcellusScript heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language.","title":"What is OcellusScript?"},{"location":"language/01-expressions/","text":"Expressions and Basic Types \u00b6 OcellusScript works like most programming languages and contains basic types: Characters are an individual alphanumeric or Unicode character wrapped in single quotes (example: '\\n' ). Strings are usually a list of Characters wrapped in double quotes (example: \"Howdy\" ). Integers are whole numbers (example: 5 ). Floats are numbers that aren't exactly whole; rather, they may be a decimal or fraction (example: 3.141 ). Booleans are a binary type that usually is either true (1) or false (0). Likewise, there are other types in Ocellus: Callables are functions, expressions, or methods. Nothing is a void type to indicate a value of nothing. Usually comparable to null or nil in other languages. It is also the default type when no value is given in an optional type . Anything is also a void type, but is often used as a container type to describe any type. Error is a String-like type that disrupts program execution flow or requires special processing. Evaluating Expressions \u00b6 OcellusScript is a functional language and mostly works off of expression evaluation. When expressions are evaluated, they will return a type and its result. Take a look at the following examples: 1 * 2 returns an Integer with a result of 2 . \"cat\" + \"dog\" returns a String with a result of \"catdog\" . true or false returns a Boolean with a result of true . Operators \u00b6 The following operators can be used to evaluate an expression: + will add values. In the case of numbers, these will mathematically add up, while in the case of strings, these will concatenate the strings together. - will subtract values, usually only with numbers. * will multiply values, usually only with numbers. / will divide numbers. In the case of integers, these will try to divide it evenly and give the whole number with no remainder. For floats, this will return the whole number and its remainder. % will get the remainder of a division, usually use with integers. == will check if two values are equal to each other.","title":"Expressions and Basic Types"},{"location":"language/01-expressions/#expressions-and-basic-types","text":"OcellusScript works like most programming languages and contains basic types: Characters are an individual alphanumeric or Unicode character wrapped in single quotes (example: '\\n' ). Strings are usually a list of Characters wrapped in double quotes (example: \"Howdy\" ). Integers are whole numbers (example: 5 ). Floats are numbers that aren't exactly whole; rather, they may be a decimal or fraction (example: 3.141 ). Booleans are a binary type that usually is either true (1) or false (0). Likewise, there are other types in Ocellus: Callables are functions, expressions, or methods. Nothing is a void type to indicate a value of nothing. Usually comparable to null or nil in other languages. It is also the default type when no value is given in an optional type . Anything is also a void type, but is often used as a container type to describe any type. Error is a String-like type that disrupts program execution flow or requires special processing.","title":"Expressions and Basic Types"},{"location":"language/01-expressions/#evaluating-expressions","text":"OcellusScript is a functional language and mostly works off of expression evaluation. When expressions are evaluated, they will return a type and its result. Take a look at the following examples: 1 * 2 returns an Integer with a result of 2 . \"cat\" + \"dog\" returns a String with a result of \"catdog\" . true or false returns a Boolean with a result of true .","title":"Evaluating Expressions"},{"location":"language/01-expressions/#operators","text":"The following operators can be used to evaluate an expression: + will add values. In the case of numbers, these will mathematically add up, while in the case of strings, these will concatenate the strings together. - will subtract values, usually only with numbers. * will multiply values, usually only with numbers. / will divide numbers. In the case of integers, these will try to divide it evenly and give the whole number with no remainder. For floats, this will return the whole number and its remainder. % will get the remainder of a division, usually use with integers. == will check if two values are equal to each other.","title":"Operators"},{"location":"language/02-functions/","text":"Defining Functions (Callables) \u00b6 The bulk of OcellusScript's language works around defining functions, which evaluate expressions when called. For example, let's write a function that evaluates the square of a given integer. This can be done by writing the following: square number = number * number Where the following apply on the left side of the equal sign: square is the name of the function. To call this function at any time, we simply refer to square . number is the name of the argument that gets passed into the expression. On the right side of the equal sign is the evaluation of the expression where we multiply the number we pass in by itself. Since the evaluation returns a number, the result of this evaluation will be the result of this function. So, now, it's possible to call upon the square function and use its result elsewhere. For example: square 4 Functions can also call upon other functions to make more complex results. For instance, the following function uses square in its evaluation: evenSquare number = (square number) % 2 == 0 First, OcellusScript will evaluate the square function and then use its result to calculate whether or not dividing it by 2 will give a remainder. OcellusScript will evaluate functions wrapped in parentheses ( () ) and work outward to the top level. Functions can also have more than one parameter. For instance, if we wanted to write a function that determines whether or not two numbers are two away from each other, we can do the following: offByTwo x y = y - x == 2 Where we now have two parameters, x and y . Order of parameters usually matters and will affect how the function is evaluated. Likewise, the offByTwo function can now be called as the following: offByTwo 3 5 Function are Not Variables It is important to keep in mind that writing functions in OcellusScript does not mean that they are variables. Any function definition is a Callable that usually returns a value. For instance, the following might look like a variable assignment in Python: helloWorld = \"Hello, world!\" When, in fact, this is not a variable. This is a parameterless function that returns the evaluation of the string \"Hello, world!\" . Type Signatures \u00b6 Type signatures are additional pieces of text above function definitions that help describe its parameters and its return type. This is used to describe the function and force type checking since OcellusScript doesn't require types to be declared immediately. For instance, let's refer to helloWorld again: helloWorld takes Nothing returns String helloWorld = \"Hello, world!\" We can now clearly see that this function is indeed a function and that it has no parameters at all. Typically, type signatures will have the following pattern: First, the function name is written to denote that the signature applies to that function. In this case, the function's name is helloWorld . takes defines the parameters and its associated types. In this case, there are no parameters, so it takes a Nothing type. returns defines the type that gets returned. In this case, the String type is returned. Likewise, this can be applies to multi-parameter functions. Take a look at the type signature for offByTwo : offByTwo takes Integer and Integer returns Boolean offByTwo x y = y - x == 2 We can now see the following: offByTwo will only work with integers as their parameters. The and indicates the second parameter. offByTwo returns a boolean value instead of a number. Callables as Parameters in a Type Signature \u00b6 There may be cases where a function itself is passed into another function as a parameter, like in higher-order functions . To accomodate for this, the type signature can be modified to indicate that it takes a function ( Callable ) with its own parameters and return type. Take a look at the example below: test takes (Callable takes Integer returns Integer) \\ and Integer returns Integer","title":"Defining Functions (Callables)"},{"location":"language/02-functions/#defining-functions-callables","text":"The bulk of OcellusScript's language works around defining functions, which evaluate expressions when called. For example, let's write a function that evaluates the square of a given integer. This can be done by writing the following: square number = number * number Where the following apply on the left side of the equal sign: square is the name of the function. To call this function at any time, we simply refer to square . number is the name of the argument that gets passed into the expression. On the right side of the equal sign is the evaluation of the expression where we multiply the number we pass in by itself. Since the evaluation returns a number, the result of this evaluation will be the result of this function. So, now, it's possible to call upon the square function and use its result elsewhere. For example: square 4 Functions can also call upon other functions to make more complex results. For instance, the following function uses square in its evaluation: evenSquare number = (square number) % 2 == 0 First, OcellusScript will evaluate the square function and then use its result to calculate whether or not dividing it by 2 will give a remainder. OcellusScript will evaluate functions wrapped in parentheses ( () ) and work outward to the top level. Functions can also have more than one parameter. For instance, if we wanted to write a function that determines whether or not two numbers are two away from each other, we can do the following: offByTwo x y = y - x == 2 Where we now have two parameters, x and y . Order of parameters usually matters and will affect how the function is evaluated. Likewise, the offByTwo function can now be called as the following: offByTwo 3 5 Function are Not Variables It is important to keep in mind that writing functions in OcellusScript does not mean that they are variables. Any function definition is a Callable that usually returns a value. For instance, the following might look like a variable assignment in Python: helloWorld = \"Hello, world!\" When, in fact, this is not a variable. This is a parameterless function that returns the evaluation of the string \"Hello, world!\" .","title":"Defining Functions (Callables)"},{"location":"language/02-functions/#type-signatures","text":"Type signatures are additional pieces of text above function definitions that help describe its parameters and its return type. This is used to describe the function and force type checking since OcellusScript doesn't require types to be declared immediately. For instance, let's refer to helloWorld again: helloWorld takes Nothing returns String helloWorld = \"Hello, world!\" We can now clearly see that this function is indeed a function and that it has no parameters at all. Typically, type signatures will have the following pattern: First, the function name is written to denote that the signature applies to that function. In this case, the function's name is helloWorld . takes defines the parameters and its associated types. In this case, there are no parameters, so it takes a Nothing type. returns defines the type that gets returned. In this case, the String type is returned. Likewise, this can be applies to multi-parameter functions. Take a look at the type signature for offByTwo : offByTwo takes Integer and Integer returns Boolean offByTwo x y = y - x == 2 We can now see the following: offByTwo will only work with integers as their parameters. The and indicates the second parameter. offByTwo returns a boolean value instead of a number.","title":"Type Signatures"},{"location":"language/02-functions/#callables-as-parameters-in-a-type-signature","text":"There may be cases where a function itself is passed into another function as a parameter, like in higher-order functions . To accomodate for this, the type signature can be modified to indicate that it takes a function ( Callable ) with its own parameters and return type. Take a look at the example below: test takes (Callable takes Integer returns Integer) \\ and Integer returns Integer","title":"Callables as Parameters in a Type Signature"},{"location":"language/03-conditionals/","text":"Conditionals \u00b6 Often, you'll need to compare two values to each other and use its comparison. These conditional operators can be used in expression evaluation: == will determine whether two values are equal to each other. != will determine whether two values are not equal to each other. < will determine whether the first value is less than the second value. > will determine whether the first value is greater than the second value. <= will determine whether the first value is less than or equal to the second value. >= will determine whether the first value is greater than or equal to the second value. It's important to note that comparisons are usually type inclusive, meaning that the types are also compared. \"2\" == 2 will always evaluate to false since the types are different, but 2 == 2 will always evaluate to true because the types are the same. Comparisons will always return a boolean value. Boolean operators \u00b6 Comparisons and conditions can work with each other using boolean operators: and determines whether both the first value and the second value will evaluate to true . not will take the opposite conditional value (i.e. true to false ). or determines whether either the first value or the second value will evaluate to true . Working with Conditionals \u00b6 The ternary operator syntax is used to determine what to further evaluate or return based on a condition. The typical syntax is as follows: condition ? (expression to evaluate if condition) : (expression to evaluate if not condition) The following is also valid syntax: condition ? true : false so, for example, the following will make a log entry depending on what gets passed into the function warnForVillain : warnForVillain name = isVillain name ? warn \"Careful! \" + villain + \" is a villain.\" : log \"You're safe.\"","title":"Conditionals"},{"location":"language/03-conditionals/#conditionals","text":"Often, you'll need to compare two values to each other and use its comparison. These conditional operators can be used in expression evaluation: == will determine whether two values are equal to each other. != will determine whether two values are not equal to each other. < will determine whether the first value is less than the second value. > will determine whether the first value is greater than the second value. <= will determine whether the first value is less than or equal to the second value. >= will determine whether the first value is greater than or equal to the second value. It's important to note that comparisons are usually type inclusive, meaning that the types are also compared. \"2\" == 2 will always evaluate to false since the types are different, but 2 == 2 will always evaluate to true because the types are the same. Comparisons will always return a boolean value.","title":"Conditionals"},{"location":"language/03-conditionals/#boolean-operators","text":"Comparisons and conditions can work with each other using boolean operators: and determines whether both the first value and the second value will evaluate to true . not will take the opposite conditional value (i.e. true to false ). or determines whether either the first value or the second value will evaluate to true .","title":"Boolean operators"},{"location":"language/03-conditionals/#working-with-conditionals","text":"The ternary operator syntax is used to determine what to further evaluate or return based on a condition. The typical syntax is as follows: condition ? (expression to evaluate if condition) : (expression to evaluate if not condition) The following is also valid syntax: condition ? true : false so, for example, the following will make a log entry depending on what gets passed into the function warnForVillain : warnForVillain name = isVillain name ? warn \"Careful! \" + villain + \" is a villain.\" : log \"You're safe.\"","title":"Working with Conditionals"},{"location":"language/04-lists/","text":"Lists and Pattern Matching \u00b6 Another common type is a list. A list is a collection of items that can be iterated through. In Ocellus, lists works more like Haskell's list in the sense that they are nested pairs with a head and tail. For instance, take a look at the following list below: [1, 2, 3, 4] The following list in OcellusScript corresponds to the following: 1 : (2 : (3 : (4 : Nothing))) Lists in OcellusScript always have a Nothing type as the inner-most tail, though the list can be of any type inside with any length. Accessing a list is relatively straightforward using this syntax: (first : second : rest) Where first corresponds to the first item in the list, second refers to the second item, and rest refers to everything else after the first two elements. This syntax can be trimmed to refer to just the first item and the rest of the items, which may be useful in recursive cases: (head : tail) Where head refers to the first item and tail refers to everything after the fist item. Additionally, referring to an item in a list without referencing pairs is relatively easy to do with the standard list[index] syntax where index is the position of the element in the list. Lists in OcellusScript start at position 0 . List Utilities \u00b6 OcellusScript comes with some utility functions that work with lists to make things a bit easier. These utility functions accept a list of type [Anything] and return different values depending on the utility in question: length list will return an Integer that represents how many items are in a list. member item list will return a Boolean that indicates whether item is an element in list . map func list will return a list of [Anything] with the function func applied to it. filter func list will return a list of [Anything] based on if the items meet the condition defined in func . reduce func list startingValue will return a single value of type Anything based on a function func and staring with value startingValue . The functions map , filter , and reduce are discussed in great detail in the Higher-order Functions section. Lists can also be added/concatenated using the standard + operator, and - will remove the first instance of an element: addList takes Nothing returns [Integer] addList = [1, 2] + [3] # returns [1, 2, 3] removeList takes Nothing returns [Integer] removeList = [1, 2, 3, 2] - [2] # returns [1, 3, 2] Pattern Matching \u00b6 Likewise, functions in OcellusScript can also cover multiple cases based on a common pattern in the input parameters. Each definition will attempt to match a specific type of pattern, so it's recommended that functions define all types of patterns that are necessary. For instance, the butFirst function below will account for empty lists, lists with one item, and lists with multiple items: butFirst takes [Anything] returns [Anything] butFirst [] = [] butFirst [x] = [x] butFirst (head:tail) = tail Note that there are three definitions listed: butFirst [] will match for empty lists specifically butFirst [x] will match for lists that contain only one item butFirst (head:tail) will match for lists that contain a head and a tail. Pattern matching works in OcellusScript regardless of the input type. For instance, take a look at the following function isEven which determines whether an optional integer is even or not: isEven takes Integer? returns Boolean isEven Nothing = false isEven number = number % 2 == 0 It is important to note that OcellusScript will match patters in the order that they are defined in. In the case of isEven , the function will attempt to match the pattern isEven Nothing before matching the pattern isEven number . OcellusScript patterns can ignore certain information by replacing it with an underscore, like below: butFirst (_ : tail) = tail Where OcellusScript will ignore the head of the list pair.","title":"Lists and Pattern Matching"},{"location":"language/04-lists/#lists-and-pattern-matching","text":"Another common type is a list. A list is a collection of items that can be iterated through. In Ocellus, lists works more like Haskell's list in the sense that they are nested pairs with a head and tail. For instance, take a look at the following list below: [1, 2, 3, 4] The following list in OcellusScript corresponds to the following: 1 : (2 : (3 : (4 : Nothing))) Lists in OcellusScript always have a Nothing type as the inner-most tail, though the list can be of any type inside with any length. Accessing a list is relatively straightforward using this syntax: (first : second : rest) Where first corresponds to the first item in the list, second refers to the second item, and rest refers to everything else after the first two elements. This syntax can be trimmed to refer to just the first item and the rest of the items, which may be useful in recursive cases: (head : tail) Where head refers to the first item and tail refers to everything after the fist item. Additionally, referring to an item in a list without referencing pairs is relatively easy to do with the standard list[index] syntax where index is the position of the element in the list. Lists in OcellusScript start at position 0 .","title":"Lists and Pattern Matching"},{"location":"language/04-lists/#list-utilities","text":"OcellusScript comes with some utility functions that work with lists to make things a bit easier. These utility functions accept a list of type [Anything] and return different values depending on the utility in question: length list will return an Integer that represents how many items are in a list. member item list will return a Boolean that indicates whether item is an element in list . map func list will return a list of [Anything] with the function func applied to it. filter func list will return a list of [Anything] based on if the items meet the condition defined in func . reduce func list startingValue will return a single value of type Anything based on a function func and staring with value startingValue . The functions map , filter , and reduce are discussed in great detail in the Higher-order Functions section. Lists can also be added/concatenated using the standard + operator, and - will remove the first instance of an element: addList takes Nothing returns [Integer] addList = [1, 2] + [3] # returns [1, 2, 3] removeList takes Nothing returns [Integer] removeList = [1, 2, 3, 2] - [2] # returns [1, 3, 2]","title":"List Utilities"},{"location":"language/04-lists/#pattern-matching","text":"Likewise, functions in OcellusScript can also cover multiple cases based on a common pattern in the input parameters. Each definition will attempt to match a specific type of pattern, so it's recommended that functions define all types of patterns that are necessary. For instance, the butFirst function below will account for empty lists, lists with one item, and lists with multiple items: butFirst takes [Anything] returns [Anything] butFirst [] = [] butFirst [x] = [x] butFirst (head:tail) = tail Note that there are three definitions listed: butFirst [] will match for empty lists specifically butFirst [x] will match for lists that contain only one item butFirst (head:tail) will match for lists that contain a head and a tail. Pattern matching works in OcellusScript regardless of the input type. For instance, take a look at the following function isEven which determines whether an optional integer is even or not: isEven takes Integer? returns Boolean isEven Nothing = false isEven number = number % 2 == 0 It is important to note that OcellusScript will match patters in the order that they are defined in. In the case of isEven , the function will attempt to match the pattern isEven Nothing before matching the pattern isEven number . OcellusScript patterns can ignore certain information by replacing it with an underscore, like below: butFirst (_ : tail) = tail Where OcellusScript will ignore the head of the list pair.","title":"Pattern Matching"},{"location":"language/05-types/","text":"Custom Types and Optionals \u00b6 OcellusScript supports writing custom data types and types that inherit basic types. This can often be used to represent trees or a specific type of data. The type function can be used to define a new type that is inherited from any of the basic types : type Side = Float type Radius = Float Where Side and Radius is a type that is inherited from the Float type. Likewise, defining custom data types is accomplished with the datatype function: datatype Shape = Rectangle Side Side or Ellipse Radius Radius Where Shape can now either be a data type of Rectangle with parameters Side and Side or a data type of Ellipse with parameters Radius and Radius . OcellusScript will work with custom types and data types as standard types in functions, which is useful in pattern matching cases. The following area function matches across different type patterns to calculate a shape's area: area takes Shape returns Float area (Rectangle x y) = x * y area (Ellipse r q) = pi * r * q Data types are often useful for creating custom types with specific attributes or for creating tree-like structures. For instance, the following code includes a custom tree data type and a function to collapse a tree into a single value with pattern matching: datatype NumberTree = Leaf Integer or Branch Integer NumberTree NumberTree collapseTree takes NumberTree returns Integer collapseTree (Leaf n) = n collapseTree (Branch n x y) n + (collapseTree x) + (collapseTree y) sampleTree = Branch 0 (Leaf 6) (Branch 1 (Leaf 2) (Leaf 9)) collapsedSample = collapseTree sampleTree Note that in the pattern collapseTree (Branch n x y) , the function calls upon itself to collapse the subtrees x and y . OcellusScript support different types of recursion and allows for this kind of behavior. Optional Types \u00b6 OcellusScript also support types that may contain a specific type of value or Nothing . These types, known as optionals , are often used in cases where the type of data being returned is unclear. Optional types are denoted by ? at the end of the type. For instance, the following function getDefaultHealth will return an integer or a default value if Nothing is received. getDefaultHealth takes Integer? returns Integer getDefaultHealth health = health ?? 100 The ?? operator in the expression indicates that the following value should be used if the preceding value is of type Nothing . Similarly, this function can be rewritten using pattern matching to make this clearer: getDefaultHealth takes Integer? returns Integer getDefaultHealth Nothing = 100 getDefaultHealth health = health Currently, functions that use optional types must account for when a type returns Nothing instead of the intended value and does not support force unwrapping. However, this behavior can be replicated (if desired) with a sample utility function like the one below: datatype ForcedValue = Anything or Error forceUnwrap takes Anything? returns ForcedValue forceUnrwap value = value ?? Error \"Cannot unwrap value Nothing.\"","title":"Custom Types and Optionals"},{"location":"language/05-types/#custom-types-and-optionals","text":"OcellusScript supports writing custom data types and types that inherit basic types. This can often be used to represent trees or a specific type of data. The type function can be used to define a new type that is inherited from any of the basic types : type Side = Float type Radius = Float Where Side and Radius is a type that is inherited from the Float type. Likewise, defining custom data types is accomplished with the datatype function: datatype Shape = Rectangle Side Side or Ellipse Radius Radius Where Shape can now either be a data type of Rectangle with parameters Side and Side or a data type of Ellipse with parameters Radius and Radius . OcellusScript will work with custom types and data types as standard types in functions, which is useful in pattern matching cases. The following area function matches across different type patterns to calculate a shape's area: area takes Shape returns Float area (Rectangle x y) = x * y area (Ellipse r q) = pi * r * q Data types are often useful for creating custom types with specific attributes or for creating tree-like structures. For instance, the following code includes a custom tree data type and a function to collapse a tree into a single value with pattern matching: datatype NumberTree = Leaf Integer or Branch Integer NumberTree NumberTree collapseTree takes NumberTree returns Integer collapseTree (Leaf n) = n collapseTree (Branch n x y) n + (collapseTree x) + (collapseTree y) sampleTree = Branch 0 (Leaf 6) (Branch 1 (Leaf 2) (Leaf 9)) collapsedSample = collapseTree sampleTree Note that in the pattern collapseTree (Branch n x y) , the function calls upon itself to collapse the subtrees x and y . OcellusScript support different types of recursion and allows for this kind of behavior.","title":"Custom Types and Optionals"},{"location":"language/05-types/#optional-types","text":"OcellusScript also support types that may contain a specific type of value or Nothing . These types, known as optionals , are often used in cases where the type of data being returned is unclear. Optional types are denoted by ? at the end of the type. For instance, the following function getDefaultHealth will return an integer or a default value if Nothing is received. getDefaultHealth takes Integer? returns Integer getDefaultHealth health = health ?? 100 The ?? operator in the expression indicates that the following value should be used if the preceding value is of type Nothing . Similarly, this function can be rewritten using pattern matching to make this clearer: getDefaultHealth takes Integer? returns Integer getDefaultHealth Nothing = 100 getDefaultHealth health = health Currently, functions that use optional types must account for when a type returns Nothing instead of the intended value and does not support force unwrapping. However, this behavior can be replicated (if desired) with a sample utility function like the one below: datatype ForcedValue = Anything or Error forceUnwrap takes Anything? returns ForcedValue forceUnrwap value = value ?? Error \"Cannot unwrap value Nothing.\"","title":"Optional Types"},{"location":"language/06-recursion/","text":"Recursion \u00b6 OcellusScript supports different types of recursion and are relatively easy to implement. The most typical form of recursion used in OcellusScript is linear recursion and works by processing a single element and constantly working on elements until the innermost element returns a single value. Elements then work upwards to \"collapse\" the work into a single evaluation. For instance, the following function below will keep working until the element value in question is divisible by 2: myEquation takes Integer returns Integer myEquation n = n % 2 == 0 ? n + 5 : myEquation (n * 2) The following would be how OcellusScript processes myEquation with the input parameter being 5 : Start with myEquation n where n = 5. Check if n is divisible by 2. n is NOT divisible by 2, so we multiply n by 2. New n = 10. Evaluate myEquation where n = 10. Check if n is divisible by 2. n IS divisible by 2, so we evaluate n + 5. n + 5 is 15. Return back value 15. Evaluation returns 15. Evaluation returns 15. where Expression \u00b6 Sometimes, it might be impractical to work with recursion and pattern matching all in a single function. To mitigate this, a helper function can be defined with the where expression. The following function reverse uses the where expression to write a pattern matching function that then can get used recursively. reverse takes String returns String reverse word = reverseHelper word \"\" where reverseHelper [] newWord = newWord reverseHelper character newWord = newWord + [character] reverseHelper (firstChar : otherChars) = reverseHelper otherChars (newWord + [firstChar]) The helper function reverseHelper gets called recursively when dealing with strings of more than one character in length and will transfer the letters over to newWord . After evaluating reverseHelper , the return value is returned to the original function. The where expression can be used to define a function preceding it or a specific value and is often used in cases of tail recursion or when pattern matching is needed. Note that the type signature for reverse does not include the signature for reverseHelper as it is not required.","title":"Recursion"},{"location":"language/06-recursion/#recursion","text":"OcellusScript supports different types of recursion and are relatively easy to implement. The most typical form of recursion used in OcellusScript is linear recursion and works by processing a single element and constantly working on elements until the innermost element returns a single value. Elements then work upwards to \"collapse\" the work into a single evaluation. For instance, the following function below will keep working until the element value in question is divisible by 2: myEquation takes Integer returns Integer myEquation n = n % 2 == 0 ? n + 5 : myEquation (n * 2) The following would be how OcellusScript processes myEquation with the input parameter being 5 : Start with myEquation n where n = 5. Check if n is divisible by 2. n is NOT divisible by 2, so we multiply n by 2. New n = 10. Evaluate myEquation where n = 10. Check if n is divisible by 2. n IS divisible by 2, so we evaluate n + 5. n + 5 is 15. Return back value 15. Evaluation returns 15. Evaluation returns 15.","title":"Recursion"},{"location":"language/06-recursion/#where-expression","text":"Sometimes, it might be impractical to work with recursion and pattern matching all in a single function. To mitigate this, a helper function can be defined with the where expression. The following function reverse uses the where expression to write a pattern matching function that then can get used recursively. reverse takes String returns String reverse word = reverseHelper word \"\" where reverseHelper [] newWord = newWord reverseHelper character newWord = newWord + [character] reverseHelper (firstChar : otherChars) = reverseHelper otherChars (newWord + [firstChar]) The helper function reverseHelper gets called recursively when dealing with strings of more than one character in length and will transfer the letters over to newWord . After evaluating reverseHelper , the return value is returned to the original function. The where expression can be used to define a function preceding it or a specific value and is often used in cases of tail recursion or when pattern matching is needed. Note that the type signature for reverse does not include the signature for reverseHelper as it is not required.","title":"where Expression"},{"location":"language/07-hoc/","text":"Higher-order Functions and Lambda Expressions \u00b6 OcellusScript supports writing functions that will accept functions as parameters. These functions, called higher-order functions, will usually take a function as one of its inputs or return a function as its output. OcellusScript comes with some built-in higher-order functions for use with iteration and lists. for \u00b6 The for function takes three inputs: a starting value, and ending value, and a callable function to run. The callable function can be written by any means and supports the where expression. An example of the for function is provided with the countToTen example where a number is logged through each iteration. countToTen takes Nothing returns Nothing countToTen = for 0 10 task where task i = log i It important to note that the for function will automatically take care of increasing the start value and decreasing the end value. The following is an implementation of the for function: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing for start end task = forHelper start start end task where forHelper i n j t = j == n ? t : forHelper (i + 1) n (j - 1) t map \u00b6 The map function is a utility function that returns a list with a function applied to its elements. It accepts two parameters: the callable function to run on each element, and the list of items to run the callable function on. The following mapIfTwo function makes use of map to change a list of numbers into a list of booleans based on their divisibility: divisibleByTwo takes Integer returns Boolean divisibleByTwo num = num % 2 == 0 mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map divisibleByTwo list Note that the divisibleByTwo function does not get called in the mapIfTwo definition as map will automatically handle this. Below is the implementation for map : map takes (Callable takes Anything returns Anything) and [Anything] \\ returns [Anything] map func x = helper func x [] where helper func [] list = list helper func i list = list + [func i] helper func (i:j) list = helper func j (list + [func i]) filter \u00b6 The filter function is a utility function that returns a list of items that obey a following condition. It accepts two parameters: the callable function that determines whether an item will be in the new list, and the list to filter. The following containsBan function makes use of filter to filter out any words in the list that do not contain the letters b, a, or n: banHelper takes String returns Boolean banHelper [] = true banHelper x = member x \"ban\" banHelper (x : xs) = (member x \"ban\") and (banHelper xs) containsBan takes [String] returns [String] containsBan list = filter banHelper list Again, note that banHelper does not get called in containsBan as filter handles this automatically. Below is the implementation for filter : filter takes (Callable takes Anything returns Boolean) and [Anything] \\ returns [Anything] filter f x = helper f x [] where helper func [] list = list helper func i list = (func i) ? list + [i] : list helper func (i:j) list = helper func j (func i) ? list + [i] : list) reduce \u00b6 The reduce function is a utility function that returns a single value of type Anything based on a method of reduction. It accepts three parameters: the callable function that dictates how values will be combined, the list to combine into a single value, and the starting value. The starting value will dictate what type the reduce function returns. The following smartAdd functions makes uses of reduce to add according to a specific set of rules: smartAdditionHelper takes Integer and Integer returns Integer smartAdditionHelper x y = y % 3 == 0 ? x + (y * 4) : x + y smartAdd takes [Integer] returns Integer smartAdd list = reduce smartAdditionHelper list 0 Again, note that smartAdditionHelper is not called inside of the smartAdd function as reduce calls this automatically when running. Below is the implementation for reduce : reduce takes (Callable takes Anything and Anything returns Anything) \\ and [Anything] and Anything returns Anything reduce f x s = helper f x s where helper combinator [] s = s helper combinator i s = combinator i s helper combinator (i:j) s = helper combinator j (combinator i s) Lambda Functions \u00b6 Sometimes it doesn't make sense to write a separate function to pass into a higher-order function like map . The lambda function is an in-line function that returns a function that evaluates a single expression from a select amount of parameters. The following example reduces the amount of code in mapIfTwo to use a lambda: mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map (lambda x -> x % 2 == 0) list This can also be used in cases like the for function: countToFive takes Nothing returns Nothing countToFive = for 0 5 (lambda x -> log x)","title":"Higher-order Functions and Lambda Expressions"},{"location":"language/07-hoc/#higher-order-functions-and-lambda-expressions","text":"OcellusScript supports writing functions that will accept functions as parameters. These functions, called higher-order functions, will usually take a function as one of its inputs or return a function as its output. OcellusScript comes with some built-in higher-order functions for use with iteration and lists.","title":"Higher-order Functions and Lambda Expressions"},{"location":"language/07-hoc/#for","text":"The for function takes three inputs: a starting value, and ending value, and a callable function to run. The callable function can be written by any means and supports the where expression. An example of the for function is provided with the countToTen example where a number is logged through each iteration. countToTen takes Nothing returns Nothing countToTen = for 0 10 task where task i = log i It important to note that the for function will automatically take care of increasing the start value and decreasing the end value. The following is an implementation of the for function: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing for start end task = forHelper start start end task where forHelper i n j t = j == n ? t : forHelper (i + 1) n (j - 1) t","title":"for"},{"location":"language/07-hoc/#map","text":"The map function is a utility function that returns a list with a function applied to its elements. It accepts two parameters: the callable function to run on each element, and the list of items to run the callable function on. The following mapIfTwo function makes use of map to change a list of numbers into a list of booleans based on their divisibility: divisibleByTwo takes Integer returns Boolean divisibleByTwo num = num % 2 == 0 mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map divisibleByTwo list Note that the divisibleByTwo function does not get called in the mapIfTwo definition as map will automatically handle this. Below is the implementation for map : map takes (Callable takes Anything returns Anything) and [Anything] \\ returns [Anything] map func x = helper func x [] where helper func [] list = list helper func i list = list + [func i] helper func (i:j) list = helper func j (list + [func i])","title":"map"},{"location":"language/07-hoc/#filter","text":"The filter function is a utility function that returns a list of items that obey a following condition. It accepts two parameters: the callable function that determines whether an item will be in the new list, and the list to filter. The following containsBan function makes use of filter to filter out any words in the list that do not contain the letters b, a, or n: banHelper takes String returns Boolean banHelper [] = true banHelper x = member x \"ban\" banHelper (x : xs) = (member x \"ban\") and (banHelper xs) containsBan takes [String] returns [String] containsBan list = filter banHelper list Again, note that banHelper does not get called in containsBan as filter handles this automatically. Below is the implementation for filter : filter takes (Callable takes Anything returns Boolean) and [Anything] \\ returns [Anything] filter f x = helper f x [] where helper func [] list = list helper func i list = (func i) ? list + [i] : list helper func (i:j) list = helper func j (func i) ? list + [i] : list)","title":"filter"},{"location":"language/07-hoc/#reduce","text":"The reduce function is a utility function that returns a single value of type Anything based on a method of reduction. It accepts three parameters: the callable function that dictates how values will be combined, the list to combine into a single value, and the starting value. The starting value will dictate what type the reduce function returns. The following smartAdd functions makes uses of reduce to add according to a specific set of rules: smartAdditionHelper takes Integer and Integer returns Integer smartAdditionHelper x y = y % 3 == 0 ? x + (y * 4) : x + y smartAdd takes [Integer] returns Integer smartAdd list = reduce smartAdditionHelper list 0 Again, note that smartAdditionHelper is not called inside of the smartAdd function as reduce calls this automatically when running. Below is the implementation for reduce : reduce takes (Callable takes Anything and Anything returns Anything) \\ and [Anything] and Anything returns Anything reduce f x s = helper f x s where helper combinator [] s = s helper combinator i s = combinator i s helper combinator (i:j) s = helper combinator j (combinator i s)","title":"reduce"},{"location":"language/07-hoc/#lambda-functions","text":"Sometimes it doesn't make sense to write a separate function to pass into a higher-order function like map . The lambda function is an in-line function that returns a function that evaluates a single expression from a select amount of parameters. The following example reduces the amount of code in mapIfTwo to use a lambda: mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map (lambda x -> x % 2 == 0) list This can also be used in cases like the for function: countToFive takes Nothing returns Nothing countToFive = for 0 5 (lambda x -> log x)","title":"Lambda Functions"},{"location":"language/08-error/","text":"Error Handling \u00b6 There may be functions that are defined in OcellusScript that might return an Error type and stop program flow. As a way to gracefully handle errors, the ternary-like ! operator syntax can be used. The following example code works with the forced unwrapped value code from the Optional Types section to handle error handling: addForcedValues takes ForcedValue returns Integer? addForcedValues x = (forceUnwrap x) ! x + 5 : log \"Couldn't unwrap value x\"","title":"Error Handling"},{"location":"language/08-error/#error-handling","text":"There may be functions that are defined in OcellusScript that might return an Error type and stop program flow. As a way to gracefully handle errors, the ternary-like ! operator syntax can be used. The following example code works with the forced unwrapped value code from the Optional Types section to handle error handling: addForcedValues takes ForcedValue returns Integer? addForcedValues x = (forceUnwrap x) ! x + 5 : log \"Couldn't unwrap value x\"","title":"Error Handling"},{"location":"language/09-modules/","text":"Modules and Main Execution \u00b6 OcellusScript works on a file-based level and supports creating and importing modules that contain other functions and utilities. When an OcellusScript file is written, it is considered a module in and of itself when the module function is defined. The following example in the file vill.ocls shows how a module is written: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) vill.ocls is a typical OcellusScript file, but because the module function is defined at the top, all functions and types in this file are publicly accessible to other OcellusScript files by importing VillainDatabase . For example, another file called chr.ocls can make use of everything inside this module by using the import function: import VillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Specific imports \u00b6 Importing the entire module may not be necessary and could cost performance. OcellusScript can handle this with specific imports. Again, with chr.ocls , we can manually import the inVillainDatabase function without importing everything else with the only statement: import VillainDatabase only inVillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Likewise, except will import the entire module except a specific function: import VillainDatabase except knownByReform foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Private functions \u00b6 Modules expose every function and type in a file and make it publicly accessible, which may not be desired. To mitigate this, adding the keyword private in front of a function definition will make sure that the function does not get imported when the module is imported. Looking back at vill.ocls , we could probably make the knownVillains function private so, say, a villain can't delete their entry from the database: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] private knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) Note that the private keyword does not need to be in the type signature of the function. Documentation Strings and Comments \u00b6 It's good practice to include documentation with your source code. Documentation often provides information on what a function will do or what a module contains. Documentation strings (docstrings) are denoted with a set of backticks (```) can be inserted between a type signature and a function definition like below: inVillainDatabase takes String returns Boolean `Check whether a villain is in the known villain database. Arguments: name: The name of the person to search for. ` inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) If you want to write comments or notes in a file, you can use a single hash ( # ) and then keep typing. OcellusScript will not execute any code in triple-quotes or after a hash. Comments with a hash extend until the next line in a file. To access documentation for a function, the help function can be called: help inVillainDatabase Where help accepts a single parameter, the callable function with a docstring. If no documentation is found, nothing is returned. Executing a File \u00b6 Thus far, we've defined functions in OcellusScript but haven't quite interacted with them. There are two ways to interact with them: Importing the module into an interactive interpreter environment Defining a main function that will be executed when running a compiled version of a script OcellusScript supports the main function to write a function that executes when you call on a file's executable: import VillainDatabase main args = log (inVillainDatabase \"Twilight\") When the file above is run after compiling, the main function will be executed. The following is the type signature of the main function: main takes [String?] returns Anything? When the file is executed, it can take in parameters from the command line as parameters to main .","title":"Modules and Main Execution"},{"location":"language/09-modules/#modules-and-main-execution","text":"OcellusScript works on a file-based level and supports creating and importing modules that contain other functions and utilities. When an OcellusScript file is written, it is considered a module in and of itself when the module function is defined. The following example in the file vill.ocls shows how a module is written: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) vill.ocls is a typical OcellusScript file, but because the module function is defined at the top, all functions and types in this file are publicly accessible to other OcellusScript files by importing VillainDatabase . For example, another file called chr.ocls can make use of everything inside this module by using the import function: import VillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\"","title":"Modules and Main Execution"},{"location":"language/09-modules/#specific-imports","text":"Importing the entire module may not be necessary and could cost performance. OcellusScript can handle this with specific imports. Again, with chr.ocls , we can manually import the inVillainDatabase function without importing everything else with the only statement: import VillainDatabase only inVillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Likewise, except will import the entire module except a specific function: import VillainDatabase except knownByReform foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\"","title":"Specific imports"},{"location":"language/09-modules/#private-functions","text":"Modules expose every function and type in a file and make it publicly accessible, which may not be desired. To mitigate this, adding the keyword private in front of a function definition will make sure that the function does not get imported when the module is imported. Looking back at vill.ocls , we could probably make the knownVillains function private so, say, a villain can't delete their entry from the database: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] private knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) Note that the private keyword does not need to be in the type signature of the function.","title":"Private functions"},{"location":"language/09-modules/#documentation-strings-and-comments","text":"It's good practice to include documentation with your source code. Documentation often provides information on what a function will do or what a module contains. Documentation strings (docstrings) are denoted with a set of backticks (```) can be inserted between a type signature and a function definition like below: inVillainDatabase takes String returns Boolean `Check whether a villain is in the known villain database. Arguments: name: The name of the person to search for. ` inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) If you want to write comments or notes in a file, you can use a single hash ( # ) and then keep typing. OcellusScript will not execute any code in triple-quotes or after a hash. Comments with a hash extend until the next line in a file. To access documentation for a function, the help function can be called: help inVillainDatabase Where help accepts a single parameter, the callable function with a docstring. If no documentation is found, nothing is returned.","title":"Documentation Strings and Comments"},{"location":"language/09-modules/#executing-a-file","text":"Thus far, we've defined functions in OcellusScript but haven't quite interacted with them. There are two ways to interact with them: Importing the module into an interactive interpreter environment Defining a main function that will be executed when running a compiled version of a script OcellusScript supports the main function to write a function that executes when you call on a file's executable: import VillainDatabase main args = log (inVillainDatabase \"Twilight\") When the file above is run after compiling, the main function will be executed. The following is the type signature of the main function: main takes [String?] returns Anything? When the file is executed, it can take in parameters from the command line as parameters to main .","title":"Executing a File"},{"location":"language/10-style/","text":"Stylebook \u00b6 While it isn't functionally necessary to follow the OcellusScript style guidelines, these guidelines can help make your code more readable and easier to understand. Keep Lines Short \u00b6 A line in OcellusScript should be no more than 100 characters in length so that it can be opened and read easily without the need for text-wrapping. Always Include Type Signatures and Docstrings \u00b6 Type signatures and docstrings are completely optional, but should be included to reduce confusion of input and output types, as well as providing sufficient documentation that can be called with help . Use Consistent Indentation \u00b6 OcellusScript files should use space indents with a length of four spaces per indent. Put Conditionals and Operators on Separate Lines \u00b6 While it is possible to do an in-line ternary operator for a conditional, if the condition evaluation is lengthy, consider putting them on separate lines: doStuff takes Integer returns Integer doStuff x = x % 5 == 1 ? x + 13 : x + 5 This should also be applied with operators and lists, if necessary: type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name myList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")] This should additionally be applied with parameters of functions, if necessary: inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) If needed, the \\ operator at the end of a line can be used to break up other components like type signatures: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing Indent Functions Defined with where \u00b6 When possible, functions that use the where syntax to be defined on the next lines should be indented: printLetters takes String returns Nothing printLetters string = for 0 (length string) task where task i = log string[i] Declare Private Functions and Types Before Functions \u00b6 When possible, any custom types, data types, and private functions should go before public functions: module Equestria where type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name private testList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")] main args = log \"Imported!\"","title":"Stylebook"},{"location":"language/10-style/#stylebook","text":"While it isn't functionally necessary to follow the OcellusScript style guidelines, these guidelines can help make your code more readable and easier to understand.","title":"Stylebook"},{"location":"language/10-style/#keep-lines-short","text":"A line in OcellusScript should be no more than 100 characters in length so that it can be opened and read easily without the need for text-wrapping.","title":"Keep Lines Short"},{"location":"language/10-style/#always-include-type-signatures-and-docstrings","text":"Type signatures and docstrings are completely optional, but should be included to reduce confusion of input and output types, as well as providing sufficient documentation that can be called with help .","title":"Always Include Type Signatures and Docstrings"},{"location":"language/10-style/#use-consistent-indentation","text":"OcellusScript files should use space indents with a length of four spaces per indent.","title":"Use Consistent Indentation"},{"location":"language/10-style/#put-conditionals-and-operators-on-separate-lines","text":"While it is possible to do an in-line ternary operator for a conditional, if the condition evaluation is lengthy, consider putting them on separate lines: doStuff takes Integer returns Integer doStuff x = x % 5 == 1 ? x + 13 : x + 5 This should also be applied with operators and lists, if necessary: type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name myList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")] This should additionally be applied with parameters of functions, if necessary: inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) If needed, the \\ operator at the end of a line can be used to break up other components like type signatures: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing","title":"Put Conditionals and Operators on Separate Lines"},{"location":"language/10-style/#indent-functions-defined-with-where","text":"When possible, functions that use the where syntax to be defined on the next lines should be indented: printLetters takes String returns Nothing printLetters string = for 0 (length string) task where task i = log string[i]","title":"Indent Functions Defined with where"},{"location":"language/10-style/#declare-private-functions-and-types-before-functions","text":"When possible, any custom types, data types, and private functions should go before public functions: module Equestria where type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name private testList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")] main args = log \"Imported!\"","title":"Declare Private Functions and Types Before Functions"},{"location":"language/11-spec/","text":"Language Specification \u00b6 The following page contains technical information about OcellusScript. This information is useful for those wishing to write a custom compiler or interpreter for OcellusScript. Lexical Elements \u00b6 During the tokenization process, OcellusScript will create tokens of the following types: Keyword refers to any of the primary keywords such as types, statements, and values. Identifier refers to a group of uppercase and lowercase letters. StringConstant refers to a string containing valid Unicode characters, excluding double quotes (unless escaped). DocstringConstant refers to a docstring containing valid Unicode characters that start and end with a backtick (```). CommentConstant refers to a comment containing valid Unicode characters that start with the hash symbol ( # ) and end with a newline character ( \\n ). Symbol refers to any non-alphanumeric characters. IntConstant refers to any integers that do not contain a decimal point. FloatConstant refers to a number that contains a single decimal point. Operator refers to any symbol used for operations and logical operators like and . Below are the lists containing valid keywords, symbols, operators, etc. Type Classified Elements Keyword Character , String , Integer , Boolean , Float , Callable , Anything , Nothing , Error , import , module , where , takes , returns , log , only , except , warn , true , false , type , datatype , private Symbol < , > , , , ? , [ , ] , ( , ) , - , = , + , * , / , % , \\ , ! , : , # Operator < , > , - , + , * , / , % , = , >= , <= , == , and , not , or , ??","title":"Language Specification"},{"location":"language/11-spec/#language-specification","text":"The following page contains technical information about OcellusScript. This information is useful for those wishing to write a custom compiler or interpreter for OcellusScript.","title":"Language Specification"},{"location":"language/11-spec/#lexical-elements","text":"During the tokenization process, OcellusScript will create tokens of the following types: Keyword refers to any of the primary keywords such as types, statements, and values. Identifier refers to a group of uppercase and lowercase letters. StringConstant refers to a string containing valid Unicode characters, excluding double quotes (unless escaped). DocstringConstant refers to a docstring containing valid Unicode characters that start and end with a backtick (```). CommentConstant refers to a comment containing valid Unicode characters that start with the hash symbol ( # ) and end with a newline character ( \\n ). Symbol refers to any non-alphanumeric characters. IntConstant refers to any integers that do not contain a decimal point. FloatConstant refers to a number that contains a single decimal point. Operator refers to any symbol used for operations and logical operators like and . Below are the lists containing valid keywords, symbols, operators, etc. Type Classified Elements Keyword Character , String , Integer , Boolean , Float , Callable , Anything , Nothing , Error , import , module , where , takes , returns , log , only , except , warn , true , false , type , datatype , private Symbol < , > , , , ? , [ , ] , ( , ) , - , = , + , * , / , % , \\ , ! , : , # Operator < , > , - , + , * , / , % , = , >= , <= , == , and , not , or , ??","title":"Lexical Elements"}]}