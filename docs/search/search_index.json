{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OcellusScript \u00b6 A Haskell-inspired functional programming language \u00b6 OcellusScript is a simple functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel . It heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language. Quick start \u00b6 Warning Efficacy is still being developed and cannot be installed from PyPI yet. You can still download the source code and build it yourself to try it out. More information on the progress of Efficacy can be read on the current progress page. To get started with writing OcellusScript code, install the Efficacy tools using pip: pip install efficacy To try compiling an example, download an example file and run the compiler: efficacy -i <filename>.ocls -o example","title":"OcellusScript"},{"location":"#ocellusscript","text":"","title":"OcellusScript"},{"location":"#a-haskell-inspired-functional-programming-language","text":"OcellusScript is a simple functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel . It heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language.","title":"A Haskell-inspired functional programming language"},{"location":"#quick-start","text":"Warning Efficacy is still being developed and cannot be installed from PyPI yet. You can still download the source code and build it yourself to try it out. More information on the progress of Efficacy can be read on the current progress page. To get started with writing OcellusScript code, install the Efficacy tools using pip: pip install efficacy To try compiling an example, download an example file and run the compiler: efficacy -i <filename>.ocls -o example","title":"Quick start"},{"location":"progress/","text":"Current Progress \u00b6 Warning OcellusScript is a work-in-progress language, so not all components of OcellusScript are functional. Below is a running checklist of what has been completed and what still needs to be worked on. Language Specification \u00b6 The language specification checklist contains all of the necessary information on how OcellusScript is defined as a language. This includes lexical elements, grammars, evaluations, etc. Lexical elements Language grammar structure Module grammars Custom type/datatype grammars Function definition grammars Expression grammars Function call grammars Note Language grammars may be updated as Efficacy's parser is developed to better represent itself. Efficacy \u00b6 Efficacy is the official lexer, parser, compiler and interpreter for OcellusScript. Lexer Parser Modules Custom types Custom datatypes Basic expressions Function calls Conditional and null expressions Function definitions Compiler Command Line Reading input files Creating token JSON files Creating abstract syntax tree JSON files Creating compiled files Interactive environment","title":"Current Progress"},{"location":"progress/#current-progress","text":"Warning OcellusScript is a work-in-progress language, so not all components of OcellusScript are functional. Below is a running checklist of what has been completed and what still needs to be worked on.","title":"Current Progress"},{"location":"progress/#language-specification","text":"The language specification checklist contains all of the necessary information on how OcellusScript is defined as a language. This includes lexical elements, grammars, evaluations, etc. Lexical elements Language grammar structure Module grammars Custom type/datatype grammars Function definition grammars Expression grammars Function call grammars Note Language grammars may be updated as Efficacy's parser is developed to better represent itself.","title":"Language Specification"},{"location":"progress/#efficacy","text":"Efficacy is the official lexer, parser, compiler and interpreter for OcellusScript. Lexer Parser Modules Custom types Custom datatypes Basic expressions Function calls Conditional and null expressions Function definitions Compiler Command Line Reading input files Creating token JSON files Creating abstract syntax tree JSON files Creating compiled files Interactive environment","title":"Efficacy"},{"location":"vscode/","text":"VS Code Extension \u00b6 The OcellusScript extension for Visual Studio code offers syntax highlighting support for OcellusScript files and includes snippets for writing pieces of code faster. Getting started \u00b6 To add this extension to your Visual Studio Code installation, search for it in the Visual Studio Marketplace and install the extension. Alternatively, you can clone the GitHub repository and install the extension to your extensions folder: git clone https://github.com/alicerunsonfedora/ocellusscript-vscode ~/.vscode/extensions/net.marquiskurt.ocellusscript-lang Snippets \u00b6 The following snippets are available out-of-the-box when installing this extension: mapf : Writes out the map higher-order function . filterf : Writes out the filter higher-order function . reducef : Writes out the map higher-order function . forf : Writes out the for higher-order function . lmbd : Writes out a boilerplate lambda expression . ifcond : Writes out a boilerplate for a conditional expression . mname : Writes out a boilerplate for a module declaration . dtype : Writes out a boilerplate for a datatype declaration .","title":"VS Code Extension"},{"location":"vscode/#vs-code-extension","text":"The OcellusScript extension for Visual Studio code offers syntax highlighting support for OcellusScript files and includes snippets for writing pieces of code faster.","title":"VS Code Extension"},{"location":"vscode/#getting-started","text":"To add this extension to your Visual Studio Code installation, search for it in the Visual Studio Marketplace and install the extension. Alternatively, you can clone the GitHub repository and install the extension to your extensions folder: git clone https://github.com/alicerunsonfedora/ocellusscript-vscode ~/.vscode/extensions/net.marquiskurt.ocellusscript-lang","title":"Getting started"},{"location":"vscode/#snippets","text":"The following snippets are available out-of-the-box when installing this extension: mapf : Writes out the map higher-order function . filterf : Writes out the filter higher-order function . reducef : Writes out the map higher-order function . forf : Writes out the for higher-order function . lmbd : Writes out a boilerplate lambda expression . ifcond : Writes out a boilerplate for a conditional expression . mname : Writes out a boilerplate for a module declaration . dtype : Writes out a boilerplate for a datatype declaration .","title":"Snippets"},{"location":"efficacy/","text":"Welcome to Efficacy \u00b6 Efficacy is the official lexer, parser, compiler, and interactive interpreter for the OcellusScript language. Efficacy can be installed as a command-line program or can be imported into Python scripts as a Python module. Efficacy currently supports Python 2.7.16 and Python 3.7+. Use Python 3 It is highly recommended that you do not use Efficacy with Python 2.7. Support for 2.7 is included only for projects that cannot be upgraded to Python 3 and is only a compatibility solution. Getting Started \u00b6 Efficacy can be installed in a Python environment using pip: pip install efficacy Alternatively, Efficacy can be added as a dependency to a Poetry project: poetry add efficacy; poetry update Table of Contents \u00b6 Usage Module","title":"Welcome <small>to Efficacy</small>"},{"location":"efficacy/#welcome-to-efficacy","text":"Efficacy is the official lexer, parser, compiler, and interactive interpreter for the OcellusScript language. Efficacy can be installed as a command-line program or can be imported into Python scripts as a Python module. Efficacy currently supports Python 2.7.16 and Python 3.7+. Use Python 3 It is highly recommended that you do not use Efficacy with Python 2.7. Support for 2.7 is included only for projects that cannot be upgraded to Python 3 and is only a compatibility solution.","title":"Welcome to Efficacy"},{"location":"efficacy/#getting-started","text":"Efficacy can be installed in a Python environment using pip: pip install efficacy Alternatively, Efficacy can be added as a dependency to a Poetry project: poetry add efficacy; poetry update","title":"Getting Started"},{"location":"efficacy/#table-of-contents","text":"Usage Module","title":"Table of Contents"},{"location":"efficacy/01-cli/","text":"Using Efficacy CLI \u00b6 The Efficacy compiler and interactive environment can be called from the terminal by running efficacy . Arguments \u00b6 The following are arguments that can be passed to Efficacy to specify details. Running Efficacy without any arguments opens the interactive mode. Argument Full Argument Required Description -i --input No 1 The path to the input file to compile -o --output No The path to where the compiled executable will be placed -oT --output-tokens No The path to where the token file will be placed -oA --output-abstract-tree No The path to where the abstract tree file will be placed Creating a Token File \u00b6 Efficacy supports creating a JSON file containing the tokens it discovered while tokenizing the input file. It mainly contains a list of objects with the token type (see Lexical Elements ) and the token itself. This token file is useful when comparing a lexer's ability to tokenize an OcellusScript file to Efficacy's lexer, OSTokenizer . Example [ { \"Identifier\" : \"x\" }, { \"Symbol\" : \"=\" }, { \"Identifier\" : \"x\" }, { \"Symbol\" : \"+\" }, { \"IntConstant\" : \"5\" }, ] Creating an Abstract Syntax Tree File \u00b6 Efficacy also supports creating a JSON file that represents the parsed abstract syntax tree from the input file. This contains a tree structure as described in the language specification , which may be useful for comparing a custom parser with Efficacy's OSParser . Example { \"module\" : { \"name\" : \"Example\" , \"importable\" : true , \"depends\" : [ \"Hive.*\" ], \"types\" : [], \"datatypes\" : [], \"functions\" : [ { \"function\" : { \"name\" : \"test\" , \"signature\" : {}, \"docstring\" : \"\" , \"body\" : [ { \"params\" : [], \"result\" : { \"expression\" : { ... } } } ] } } ] } } The input argument is required when compiling files or preparing a tokenized or parsed JSON file. \u21a9","title":"Using Efficacy CLI"},{"location":"efficacy/01-cli/#using-efficacy-cli","text":"The Efficacy compiler and interactive environment can be called from the terminal by running efficacy .","title":"Using Efficacy CLI"},{"location":"efficacy/01-cli/#arguments","text":"The following are arguments that can be passed to Efficacy to specify details. Running Efficacy without any arguments opens the interactive mode. Argument Full Argument Required Description -i --input No 1 The path to the input file to compile -o --output No The path to where the compiled executable will be placed -oT --output-tokens No The path to where the token file will be placed -oA --output-abstract-tree No The path to where the abstract tree file will be placed","title":"Arguments"},{"location":"efficacy/01-cli/#creating-a-token-file","text":"Efficacy supports creating a JSON file containing the tokens it discovered while tokenizing the input file. It mainly contains a list of objects with the token type (see Lexical Elements ) and the token itself. This token file is useful when comparing a lexer's ability to tokenize an OcellusScript file to Efficacy's lexer, OSTokenizer . Example [ { \"Identifier\" : \"x\" }, { \"Symbol\" : \"=\" }, { \"Identifier\" : \"x\" }, { \"Symbol\" : \"+\" }, { \"IntConstant\" : \"5\" }, ]","title":"Creating a Token File"},{"location":"efficacy/01-cli/#creating-an-abstract-syntax-tree-file","text":"Efficacy also supports creating a JSON file that represents the parsed abstract syntax tree from the input file. This contains a tree structure as described in the language specification , which may be useful for comparing a custom parser with Efficacy's OSParser . Example { \"module\" : { \"name\" : \"Example\" , \"importable\" : true , \"depends\" : [ \"Hive.*\" ], \"types\" : [], \"datatypes\" : [], \"functions\" : [ { \"function\" : { \"name\" : \"test\" , \"signature\" : {}, \"docstring\" : \"\" , \"body\" : [ { \"params\" : [], \"result\" : { \"expression\" : { ... } } } ] } } ] } } The input argument is required when compiling files or preparing a tokenized or parsed JSON file. \u21a9","title":"Creating an Abstract Syntax Tree File"},{"location":"efficacy/module/","text":"The Efficacy Module \u00b6 Efficacy can be used in Python scripts and projects as an importable module. The following documentation covers all of the publicly-facing APIs and utilities available in the Efficacy package. Table of Contents \u00b6 CLI Lexer Parser","title":"The Efficacy Module"},{"location":"efficacy/module/#the-efficacy-module","text":"Efficacy can be used in Python scripts and projects as an importable module. The following documentation covers all of the publicly-facing APIs and utilities available in the Efficacy package.","title":"The Efficacy Module"},{"location":"efficacy/module/#table-of-contents","text":"CLI Lexer Parser","title":"Table of Contents"},{"location":"efficacy/module/00-cli/","text":"CLI \u00b6 The cli submodule of Efficacy contains the source code and functionality for the command-line application version of the Efficacy compiler. run_cli \u00b6 Start the main process for the CLI application. Arguments with_args : (Optional) The arguments to run the CLI with (see Using Efficacy CLI ). Will default to sys.argv if no arguments have been supplied. Example Below is an example of how the CLI can be called programmatically using run_cli() . from efficacy.cli import run_cli from subproccess import check_call print ( check_call ( run_cli ([ \"-i\" , \"main.ocls\" , \"-oT\" , \"tokens.json\" ])))","title":"CLI"},{"location":"efficacy/module/00-cli/#cli","text":"The cli submodule of Efficacy contains the source code and functionality for the command-line application version of the Efficacy compiler.","title":"CLI"},{"location":"efficacy/module/00-cli/#run_cli","text":"Start the main process for the CLI application. Arguments with_args : (Optional) The arguments to run the CLI with (see Using Efficacy CLI ). Will default to sys.argv if no arguments have been supplied. Example Below is an example of how the CLI can be called programmatically using run_cli() . from efficacy.cli import run_cli from subproccess import check_call print ( check_call ( run_cli ([ \"-i\" , \"main.ocls\" , \"-oT\" , \"tokens.json\" ])))","title":"run_cli"},{"location":"efficacy/module/01-lexer/","text":"Lexer \u00b6 The lexer submodule of Efficacy contains all of the tools necessary to tokenize a string or a file into a a list of OcellusScript tokens. OSTokenType \u00b6 An enumeration type for the different token types. This enumeration class is used to differentiate between the different types of tokens used for OcellusScript parsing. The values of the enumerations correspond to the lexical grammar names for each type. Key Corresponding Value keyword Keyword identifier Identifier string StringConstant docstring DocstringConstant comment CommentConstant symbol Symbol num_integer IntConstant num_float FloatConstant operator Operator newline LineReturn OSTokenizer \u00b6 The tokenizing class for OcellusScript. The tokenizer is responsible for converting a stream of characters into OcellusScript tokens that can be used for parsing. Example Below is an example of how OSTokenizer can be used to create a list of tokens from a string containing OcellusScript code. from efficacy.lexer import OSTokenizer lexer = OSTokenizer ( script = \"example x = x > 5 ? x + 6 : x + 8 \\n \" ) tokens = lexer . tokenize () print ( tokens [ 0 ]) # (<OSTokenType: OSTokenType.identifier>, \"example\") Attributes \u00b6 source : The list of characters that will be converted to tokens Methods \u00b6 __init__ \u00b6 Initialize the tokenizer. Arguments script : The script string to tokenize tokenize \u00b6 Generate a list of tokens from a given string. Returns : A list containing the tokens as a tuple containing the token's type and the token itself.","title":"Lexer"},{"location":"efficacy/module/01-lexer/#lexer","text":"The lexer submodule of Efficacy contains all of the tools necessary to tokenize a string or a file into a a list of OcellusScript tokens.","title":"Lexer"},{"location":"efficacy/module/01-lexer/#ostokentype","text":"An enumeration type for the different token types. This enumeration class is used to differentiate between the different types of tokens used for OcellusScript parsing. The values of the enumerations correspond to the lexical grammar names for each type. Key Corresponding Value keyword Keyword identifier Identifier string StringConstant docstring DocstringConstant comment CommentConstant symbol Symbol num_integer IntConstant num_float FloatConstant operator Operator newline LineReturn","title":"OSTokenType"},{"location":"efficacy/module/01-lexer/#ostokenizer","text":"The tokenizing class for OcellusScript. The tokenizer is responsible for converting a stream of characters into OcellusScript tokens that can be used for parsing. Example Below is an example of how OSTokenizer can be used to create a list of tokens from a string containing OcellusScript code. from efficacy.lexer import OSTokenizer lexer = OSTokenizer ( script = \"example x = x > 5 ? x + 6 : x + 8 \\n \" ) tokens = lexer . tokenize () print ( tokens [ 0 ]) # (<OSTokenType: OSTokenType.identifier>, \"example\")","title":"OSTokenizer"},{"location":"efficacy/module/01-lexer/#attributes","text":"source : The list of characters that will be converted to tokens","title":"Attributes"},{"location":"efficacy/module/01-lexer/#methods","text":"","title":"Methods"},{"location":"efficacy/module/01-lexer/#__init__","text":"Initialize the tokenizer. Arguments script : The script string to tokenize","title":"__init__"},{"location":"efficacy/module/01-lexer/#tokenize","text":"Generate a list of tokens from a given string. Returns : A list containing the tokens as a tuple containing the token's type and the token itself.","title":"tokenize"},{"location":"efficacy/module/02-parser/","text":"Parser \u00b6 The parser submodule of Efficacy contains all of the tools necessary to parse a list of tokens into an abstract syntax tree to be used for compilation or additional processing. OSParserError \u00b6 The base error to use when the parser has failed. OSParser \u00b6 The parsing class for OcellusScript. The parser is responsible for reading a list of tokens and converting the them into a traversable abstract syntax tree that can be used to compile into a program with LLVM or can be processed differently with a Python script. Example The following is an example of how the parser can be used to create the abstract syntax tree. from efficacy.parser import OSParser example_src = \"\"\"module Example where example takes Nothing returns Integer example = 5\"\"\" parsed = OSParser ( script = example_src ) . parse () print ( parsed ) Methods \u00b6 __init__ \u00b6 Initialize the OcellusScript Parser object. Keyword Arguments - script : The string containing the code to parse. The parser will tokenize this script before parsing it. - tokens : The pre-processed list of tokens to use for parsing. parse \u00b6 Parse the list of tokens and return an abstract syntax tree. Arguments skip_new_line : Whether to skip the newline token ( LineReturn ). Defaults to True . Returns : A JSON-like dictionary containing all of the parsed functions, expression, and modules. Raises : OSParserError if there's an error in the syntax of the current token being processed.","title":"Parser"},{"location":"efficacy/module/02-parser/#parser","text":"The parser submodule of Efficacy contains all of the tools necessary to parse a list of tokens into an abstract syntax tree to be used for compilation or additional processing.","title":"Parser"},{"location":"efficacy/module/02-parser/#osparsererror","text":"The base error to use when the parser has failed.","title":"OSParserError"},{"location":"efficacy/module/02-parser/#osparser","text":"The parsing class for OcellusScript. The parser is responsible for reading a list of tokens and converting the them into a traversable abstract syntax tree that can be used to compile into a program with LLVM or can be processed differently with a Python script. Example The following is an example of how the parser can be used to create the abstract syntax tree. from efficacy.parser import OSParser example_src = \"\"\"module Example where example takes Nothing returns Integer example = 5\"\"\" parsed = OSParser ( script = example_src ) . parse () print ( parsed )","title":"OSParser"},{"location":"efficacy/module/02-parser/#methods","text":"","title":"Methods"},{"location":"efficacy/module/02-parser/#__init__","text":"Initialize the OcellusScript Parser object. Keyword Arguments - script : The string containing the code to parse. The parser will tokenize this script before parsing it. - tokens : The pre-processed list of tokens to use for parsing.","title":"__init__"},{"location":"efficacy/module/02-parser/#parse","text":"Parse the list of tokens and return an abstract syntax tree. Arguments skip_new_line : Whether to skip the newline token ( LineReturn ). Defaults to True . Returns : A JSON-like dictionary containing all of the parsed functions, expression, and modules. Raises : OSParserError if there's an error in the syntax of the current token being processed.","title":"parse"},{"location":"language/","text":"Welcome to OcellusScript \u00b6 The following documentation will guide you through learning the general syntax and nature of OcellusScript. What is OcellusScript? \u00b6 OcellusScript is a functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel. OcellusScript heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language. Table of Contents \u00b6 Expressions and Basic Types Defining Functions (Callables) Conditionals Lists and Pattern Matching Custom Types and Optionals Recursion Higher-order Functions and Lambda Expressions Error Handling Modules and Main Execution Stylebook Specification","title":"Welcome <small>to OcellusScript</small>"},{"location":"language/#welcome-to-ocellusscript","text":"The following documentation will guide you through learning the general syntax and nature of OcellusScript.","title":"Welcome to OcellusScript"},{"location":"language/#what-is-ocellusscript","text":"OcellusScript is a functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel. OcellusScript heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language.","title":"What is OcellusScript?"},{"location":"language/#table-of-contents","text":"Expressions and Basic Types Defining Functions (Callables) Conditionals Lists and Pattern Matching Custom Types and Optionals Recursion Higher-order Functions and Lambda Expressions Error Handling Modules and Main Execution Stylebook Specification","title":"Table of Contents"},{"location":"language/01-expressions/","text":"Expressions and Basic Types \u00b6 OcellusScript works like most programming languages and contains basic types: Characters are an individual alphanumeric or Unicode character wrapped in single quotes (example: '\\n' ). Strings are usually a list of Characters wrapped in double quotes (example: \"Howdy\" ). Integers are whole numbers (example: 5 ). Floats are numbers that aren't exactly whole; rather, they may be a decimal or fraction (example: 3.141 ). Booleans are a binary type that usually is either true (1) or false (0). Likewise, there are other types in Ocellus: Callables are functions, expressions, or methods. Nothing is a void type to indicate a value of nothing. Usually comparable to null or nil in other languages. It is also the default type when no value is given in an optional type . Anything is also a void type, but is often used as a container type to describe any type. Error is a String-like type that disrupts program execution flow or requires special processing. Evaluating Expressions \u00b6 OcellusScript is a functional language and mostly works off of expression evaluation. When expressions are evaluated, they will return a type and its result. Take a look at the following examples: 1 * 2 returns an Integer with a result of 2 . \"cat\" + \"dog\" returns a String with a result of \"catdog\" . true or false returns a Boolean with a result of true . Operators \u00b6 The following operators can be used to evaluate an expression: + will add values. In the case of numbers, these will mathematically add up, while in the case of strings, these will concatenate the strings together. - will subtract values, usually only with numbers. * will multiply values, usually only with numbers. / will divide numbers. In the case of integers, these will try to divide it evenly and give the whole number with no remainder. For floats, this will return the whole number and its remainder. % will get the remainder of a division, usually use with integers. == will check if two values are equal to each other. Expression Precedence \u00b6 OcellusScript will handle certain expressions a little bit differently and follow a specific order of operations. The following is the order of precedence ind descending order (i.e., highest at the top). Basic expression types ( 8 ), expressions wrapped in parentheses ( (7 - 2) ), and/or lists ( [1, 2, 3] ) Multiplicative expressions such as multiplication ( g * 5 ), division ( g / 5 ), and remainder division (modulus) ( g % 5 ) Additive expressions such as addition ( m + 7 ) and subtraction ( m - 5 ) Basic inequality expressions such as greater-than ( h > 5 ) and less-than ( h < 5 ) Complex inequality expressions such as greater-than-or-equal-to ( m >= 8 ) and less-than-or-equal-to ( h <= 5 ) Equality expressions ( m == g or m != g ) Boolean expressions ( a and b , a or b , not a ) Conditional expressions ( a ? b : c ) Sometimes, OcellusScript may be unaware of when an expression is meant to be evaluated before an outer expression. Wrap your expression in parentheses to avoid this: example f = f > 5 ? f : -1 # Syntax error example f = (f > 5) ? f : -1 # OK","title":"Expressions and Basic Types"},{"location":"language/01-expressions/#expressions-and-basic-types","text":"OcellusScript works like most programming languages and contains basic types: Characters are an individual alphanumeric or Unicode character wrapped in single quotes (example: '\\n' ). Strings are usually a list of Characters wrapped in double quotes (example: \"Howdy\" ). Integers are whole numbers (example: 5 ). Floats are numbers that aren't exactly whole; rather, they may be a decimal or fraction (example: 3.141 ). Booleans are a binary type that usually is either true (1) or false (0). Likewise, there are other types in Ocellus: Callables are functions, expressions, or methods. Nothing is a void type to indicate a value of nothing. Usually comparable to null or nil in other languages. It is also the default type when no value is given in an optional type . Anything is also a void type, but is often used as a container type to describe any type. Error is a String-like type that disrupts program execution flow or requires special processing.","title":"Expressions and Basic Types"},{"location":"language/01-expressions/#evaluating-expressions","text":"OcellusScript is a functional language and mostly works off of expression evaluation. When expressions are evaluated, they will return a type and its result. Take a look at the following examples: 1 * 2 returns an Integer with a result of 2 . \"cat\" + \"dog\" returns a String with a result of \"catdog\" . true or false returns a Boolean with a result of true .","title":"Evaluating Expressions"},{"location":"language/01-expressions/#operators","text":"The following operators can be used to evaluate an expression: + will add values. In the case of numbers, these will mathematically add up, while in the case of strings, these will concatenate the strings together. - will subtract values, usually only with numbers. * will multiply values, usually only with numbers. / will divide numbers. In the case of integers, these will try to divide it evenly and give the whole number with no remainder. For floats, this will return the whole number and its remainder. % will get the remainder of a division, usually use with integers. == will check if two values are equal to each other.","title":"Operators"},{"location":"language/01-expressions/#expression-precedence","text":"OcellusScript will handle certain expressions a little bit differently and follow a specific order of operations. The following is the order of precedence ind descending order (i.e., highest at the top). Basic expression types ( 8 ), expressions wrapped in parentheses ( (7 - 2) ), and/or lists ( [1, 2, 3] ) Multiplicative expressions such as multiplication ( g * 5 ), division ( g / 5 ), and remainder division (modulus) ( g % 5 ) Additive expressions such as addition ( m + 7 ) and subtraction ( m - 5 ) Basic inequality expressions such as greater-than ( h > 5 ) and less-than ( h < 5 ) Complex inequality expressions such as greater-than-or-equal-to ( m >= 8 ) and less-than-or-equal-to ( h <= 5 ) Equality expressions ( m == g or m != g ) Boolean expressions ( a and b , a or b , not a ) Conditional expressions ( a ? b : c ) Sometimes, OcellusScript may be unaware of when an expression is meant to be evaluated before an outer expression. Wrap your expression in parentheses to avoid this: example f = f > 5 ? f : -1 # Syntax error example f = (f > 5) ? f : -1 # OK","title":"Expression Precedence"},{"location":"language/02-functions/","text":"Defining Functions (Callables) \u00b6 The bulk of OcellusScript's language works around defining functions, which evaluate expressions when called. For example, let's write a function that evaluates the square of a given integer. This can be done by writing the following: square number = number * number Where the following apply on the left side of the equal sign: square is the name of the function. To call this function at any time, we simply refer to square . number is the name of the argument that gets passed into the expression. On the right side of the equal sign is the evaluation of the expression where we multiply the number we pass in by itself. Since the evaluation returns a number, the result of this evaluation will be the result of this function. So, now, it's possible to call upon the square function and use its result elsewhere. For example: square 4 Functions can also call upon other functions to make more complex results. For instance, the following function uses square in its evaluation: evenSquare number = (square number) % 2 == 0 First, OcellusScript will evaluate the square function and then use its result to calculate whether or not dividing it by 2 will give a remainder. OcellusScript will evaluate functions wrapped in parentheses ( () ) and work outward to the top level. Functions can also have more than one parameter. For instance, if we wanted to write a function that determines whether or not two numbers are two away from each other, we can do the following: offByTwo x y = y - x == 2 Where we now have two parameters, x and y . Order of parameters usually matters and will affect how the function is evaluated. Likewise, the offByTwo function can now be called as the following: offByTwo 3 5 Function are Not Variables It is important to keep in mind that writing functions in OcellusScript does not mean that they are variables. Any function definition is a Callable that usually returns a value. For instance, the following might look like a variable assignment in Python: helloWorld = \"Hello, world!\" When, in fact, this is not a variable. This is a parameterless function that returns the evaluation of the string \"Hello, world!\" . Type Signatures \u00b6 Type signatures are additional pieces of text above function definitions that help describe its parameters and its return type. This is used to describe the function and force type checking since OcellusScript doesn't require types to be declared immediately. For instance, let's refer to helloWorld again: helloWorld takes Nothing returns String helloWorld = \"Hello, world!\" We can now clearly see that this function is indeed a function and that it has no parameters at all. Typically, type signatures will have the following pattern: First, the function name is written to denote that the signature applies to that function. In this case, the function's name is helloWorld . takes defines the parameters and its associated types. In this case, there are no parameters, so it takes a Nothing type. returns defines the type that gets returned. In this case, the String type is returned. Likewise, this can be applies to multi-parameter functions. Take a look at the type signature for offByTwo : offByTwo takes Integer and Integer returns Boolean offByTwo x y = y - x == 2 We can now see the following: offByTwo will only work with integers as their parameters. The and indicates the second parameter. offByTwo returns a boolean value instead of a number. Callables as Parameters in a Type Signature \u00b6 There may be cases where a function itself is passed into another function as a parameter, like in higher-order functions . To accomodate for this, the type signature can be modified to indicate that it takes a function ( Callable ) with its own parameters and return type. Take a look at the example below: test takes (Callable takes Integer returns Integer) \\ and Integer returns Integer","title":"Defining Functions (Callables)"},{"location":"language/02-functions/#defining-functions-callables","text":"The bulk of OcellusScript's language works around defining functions, which evaluate expressions when called. For example, let's write a function that evaluates the square of a given integer. This can be done by writing the following: square number = number * number Where the following apply on the left side of the equal sign: square is the name of the function. To call this function at any time, we simply refer to square . number is the name of the argument that gets passed into the expression. On the right side of the equal sign is the evaluation of the expression where we multiply the number we pass in by itself. Since the evaluation returns a number, the result of this evaluation will be the result of this function. So, now, it's possible to call upon the square function and use its result elsewhere. For example: square 4 Functions can also call upon other functions to make more complex results. For instance, the following function uses square in its evaluation: evenSquare number = (square number) % 2 == 0 First, OcellusScript will evaluate the square function and then use its result to calculate whether or not dividing it by 2 will give a remainder. OcellusScript will evaluate functions wrapped in parentheses ( () ) and work outward to the top level. Functions can also have more than one parameter. For instance, if we wanted to write a function that determines whether or not two numbers are two away from each other, we can do the following: offByTwo x y = y - x == 2 Where we now have two parameters, x and y . Order of parameters usually matters and will affect how the function is evaluated. Likewise, the offByTwo function can now be called as the following: offByTwo 3 5 Function are Not Variables It is important to keep in mind that writing functions in OcellusScript does not mean that they are variables. Any function definition is a Callable that usually returns a value. For instance, the following might look like a variable assignment in Python: helloWorld = \"Hello, world!\" When, in fact, this is not a variable. This is a parameterless function that returns the evaluation of the string \"Hello, world!\" .","title":"Defining Functions (Callables)"},{"location":"language/02-functions/#type-signatures","text":"Type signatures are additional pieces of text above function definitions that help describe its parameters and its return type. This is used to describe the function and force type checking since OcellusScript doesn't require types to be declared immediately. For instance, let's refer to helloWorld again: helloWorld takes Nothing returns String helloWorld = \"Hello, world!\" We can now clearly see that this function is indeed a function and that it has no parameters at all. Typically, type signatures will have the following pattern: First, the function name is written to denote that the signature applies to that function. In this case, the function's name is helloWorld . takes defines the parameters and its associated types. In this case, there are no parameters, so it takes a Nothing type. returns defines the type that gets returned. In this case, the String type is returned. Likewise, this can be applies to multi-parameter functions. Take a look at the type signature for offByTwo : offByTwo takes Integer and Integer returns Boolean offByTwo x y = y - x == 2 We can now see the following: offByTwo will only work with integers as their parameters. The and indicates the second parameter. offByTwo returns a boolean value instead of a number.","title":"Type Signatures"},{"location":"language/02-functions/#callables-as-parameters-in-a-type-signature","text":"There may be cases where a function itself is passed into another function as a parameter, like in higher-order functions . To accomodate for this, the type signature can be modified to indicate that it takes a function ( Callable ) with its own parameters and return type. Take a look at the example below: test takes (Callable takes Integer returns Integer) \\ and Integer returns Integer","title":"Callables as Parameters in a Type Signature"},{"location":"language/03-conditionals/","text":"Conditionals \u00b6 Often, you'll need to compare two values to each other and use its comparison. These conditional operators can be used in expression evaluation: == will determine whether two values are equal to each other. != will determine whether two values are not equal to each other. < will determine whether the first value is less than the second value. > will determine whether the first value is greater than the second value. <= will determine whether the first value is less than or equal to the second value. >= will determine whether the first value is greater than or equal to the second value. It's important to note that comparisons are usually type inclusive, meaning that the types are also compared. \"2\" == 2 will always evaluate to false since the types are different, but 2 == 2 will always evaluate to true because the types are the same. Comparisons will always return a boolean value. Boolean operators \u00b6 Comparisons and conditions can work with each other using boolean operators: and determines whether both the first value and the second value will evaluate to true . not will take the opposite conditional value (i.e. true to false ). or determines whether either the first value or the second value will evaluate to true . Working with Conditionals \u00b6 The ternary operator syntax is used to determine what to further evaluate or return based on a condition. The typical syntax is as follows: (condition) ? (expression to evaluate if condition) : (expression to evaluate if not condition) The following is also valid syntax: condition ? true : false so, for example, the following will make a log entry depending on what gets passed into the function warnForVillain : warnForVillain name = (isVillain name) ? (warn \"Careful! \" + villain + \" is a villain.\") : (log \"You're safe.\")","title":"Conditionals"},{"location":"language/03-conditionals/#conditionals","text":"Often, you'll need to compare two values to each other and use its comparison. These conditional operators can be used in expression evaluation: == will determine whether two values are equal to each other. != will determine whether two values are not equal to each other. < will determine whether the first value is less than the second value. > will determine whether the first value is greater than the second value. <= will determine whether the first value is less than or equal to the second value. >= will determine whether the first value is greater than or equal to the second value. It's important to note that comparisons are usually type inclusive, meaning that the types are also compared. \"2\" == 2 will always evaluate to false since the types are different, but 2 == 2 will always evaluate to true because the types are the same. Comparisons will always return a boolean value.","title":"Conditionals"},{"location":"language/03-conditionals/#boolean-operators","text":"Comparisons and conditions can work with each other using boolean operators: and determines whether both the first value and the second value will evaluate to true . not will take the opposite conditional value (i.e. true to false ). or determines whether either the first value or the second value will evaluate to true .","title":"Boolean operators"},{"location":"language/03-conditionals/#working-with-conditionals","text":"The ternary operator syntax is used to determine what to further evaluate or return based on a condition. The typical syntax is as follows: (condition) ? (expression to evaluate if condition) : (expression to evaluate if not condition) The following is also valid syntax: condition ? true : false so, for example, the following will make a log entry depending on what gets passed into the function warnForVillain : warnForVillain name = (isVillain name) ? (warn \"Careful! \" + villain + \" is a villain.\") : (log \"You're safe.\")","title":"Working with Conditionals"},{"location":"language/04-lists/","text":"Lists and Pattern Matching \u00b6 Another common type is a list. A list is a collection of items that can be iterated through. In Ocellus, lists works more like Haskell's list in the sense that they are nested pairs with a head and tail. For instance, take a look at the following list below: [1, 2, 3, 4] The following list in OcellusScript corresponds to the following: 1 : (2 : (3 : (4 : Nothing))) Lists in OcellusScript always have a Nothing type as the inner-most tail, though the list can be of any type inside with any length. Accessing a list is relatively straightforward using this syntax: (first : second : rest) Where first corresponds to the first item in the list, second refers to the second item, and rest refers to everything else after the first two elements. This syntax can be trimmed to refer to just the first item and the rest of the items, which may be useful in recursive cases: (head : tail) Where head refers to the first item and tail refers to everything after the fist item. Additionally, referring to an item in a list without referencing pairs is relatively easy to do with the standard list[index] syntax where index is the position of the element in the list. Lists in OcellusScript start at position 0 . List Utilities \u00b6 OcellusScript comes with some utility functions that work with lists to make things a bit easier. These utility functions accept a list of type [Anything] and return different values depending on the utility in question: length list will return an Integer that represents how many items are in a list. member item list will return a Boolean that indicates whether item is an element in list . map func list will return a list of [Anything] with the function func applied to it. filter func list will return a list of [Anything] based on if the items meet the condition defined in func . reduce func list startingValue will return a single value of type Anything based on a function func and staring with value startingValue . The functions map , filter , and reduce are discussed in great detail in the Higher-order Functions section. Lists can also be added/concatenated using the standard + operator, and - will remove the first instance of an element: addList takes Nothing returns [Integer] addList = [1, 2] + [3] # returns [1, 2, 3] removeList takes Nothing returns [Integer] removeList = [1, 2, 3, 2] - [2] # returns [1, 3, 2] Pattern Matching \u00b6 Likewise, functions in OcellusScript can also cover multiple cases based on a common pattern in the input parameters. Each definition will attempt to match a specific type of pattern, so it's recommended that functions define all types of patterns that are necessary. For instance, the butFirst function below will account for empty lists, lists with one item, and lists with multiple items: butFirst takes [Anything] returns [Anything] butFirst [] = [] butFirst [x] = [x] butFirst (head:tail) = tail Note that there are three definitions listed: butFirst [] will match for empty lists specifically butFirst [x] will match for lists that contain only one item butFirst (head:tail) will match for lists that contain a head and a tail. Pattern matching works in OcellusScript regardless of the input type. For instance, take a look at the following function isEven which determines whether an optional integer is even or not: isEven takes Integer? returns Boolean isEven Nothing = false isEven number = number % 2 == 0 It is important to note that OcellusScript will match patters in the order that they are defined in. In the case of isEven , the function will attempt to match the pattern isEven Nothing before matching the pattern isEven number . OcellusScript patterns can ignore certain information by replacing it with an underscore, like below: butFirst (_ : tail) = tail Where OcellusScript will ignore the head of the list pair.","title":"Lists and Pattern Matching"},{"location":"language/04-lists/#lists-and-pattern-matching","text":"Another common type is a list. A list is a collection of items that can be iterated through. In Ocellus, lists works more like Haskell's list in the sense that they are nested pairs with a head and tail. For instance, take a look at the following list below: [1, 2, 3, 4] The following list in OcellusScript corresponds to the following: 1 : (2 : (3 : (4 : Nothing))) Lists in OcellusScript always have a Nothing type as the inner-most tail, though the list can be of any type inside with any length. Accessing a list is relatively straightforward using this syntax: (first : second : rest) Where first corresponds to the first item in the list, second refers to the second item, and rest refers to everything else after the first two elements. This syntax can be trimmed to refer to just the first item and the rest of the items, which may be useful in recursive cases: (head : tail) Where head refers to the first item and tail refers to everything after the fist item. Additionally, referring to an item in a list without referencing pairs is relatively easy to do with the standard list[index] syntax where index is the position of the element in the list. Lists in OcellusScript start at position 0 .","title":"Lists and Pattern Matching"},{"location":"language/04-lists/#list-utilities","text":"OcellusScript comes with some utility functions that work with lists to make things a bit easier. These utility functions accept a list of type [Anything] and return different values depending on the utility in question: length list will return an Integer that represents how many items are in a list. member item list will return a Boolean that indicates whether item is an element in list . map func list will return a list of [Anything] with the function func applied to it. filter func list will return a list of [Anything] based on if the items meet the condition defined in func . reduce func list startingValue will return a single value of type Anything based on a function func and staring with value startingValue . The functions map , filter , and reduce are discussed in great detail in the Higher-order Functions section. Lists can also be added/concatenated using the standard + operator, and - will remove the first instance of an element: addList takes Nothing returns [Integer] addList = [1, 2] + [3] # returns [1, 2, 3] removeList takes Nothing returns [Integer] removeList = [1, 2, 3, 2] - [2] # returns [1, 3, 2]","title":"List Utilities"},{"location":"language/04-lists/#pattern-matching","text":"Likewise, functions in OcellusScript can also cover multiple cases based on a common pattern in the input parameters. Each definition will attempt to match a specific type of pattern, so it's recommended that functions define all types of patterns that are necessary. For instance, the butFirst function below will account for empty lists, lists with one item, and lists with multiple items: butFirst takes [Anything] returns [Anything] butFirst [] = [] butFirst [x] = [x] butFirst (head:tail) = tail Note that there are three definitions listed: butFirst [] will match for empty lists specifically butFirst [x] will match for lists that contain only one item butFirst (head:tail) will match for lists that contain a head and a tail. Pattern matching works in OcellusScript regardless of the input type. For instance, take a look at the following function isEven which determines whether an optional integer is even or not: isEven takes Integer? returns Boolean isEven Nothing = false isEven number = number % 2 == 0 It is important to note that OcellusScript will match patters in the order that they are defined in. In the case of isEven , the function will attempt to match the pattern isEven Nothing before matching the pattern isEven number . OcellusScript patterns can ignore certain information by replacing it with an underscore, like below: butFirst (_ : tail) = tail Where OcellusScript will ignore the head of the list pair.","title":"Pattern Matching"},{"location":"language/05-types/","text":"Custom Types and Optionals \u00b6 OcellusScript supports writing custom data types and types that inherit basic types. This can often be used to represent trees or a specific type of data. The type function can be used to define a new type that is inherited from any of the basic types : type Side = Float type Radius = Float Where Side and Radius is a type that is inherited from the Float type. Likewise, defining custom data types is accomplished with the datatype function: datatype Shape = Rectangle Side Side or Ellipse Radius Radius Where Shape can now either be a data type of Rectangle with parameters Side and Side or a data type of Ellipse with parameters Radius and Radius . Naming Types Custom types and datatype structures must always be named in Pascal case ( PascalCase ) to avoid confusion with other functions and keywords. OcellusScript will work with custom types and data types as standard types in functions, which is useful in pattern matching cases. The following area function matches across different type patterns to calculate a shape's area: area takes Shape returns Float area (Rectangle x y) = x * y area (Ellipse r q) = pi * r * q Data types are often useful for creating custom types with specific attributes or for creating tree-like structures. For instance, the following code includes a custom tree data type and a function to collapse a tree into a single value with pattern matching: datatype NumberTree = Leaf Integer or Branch Integer NumberTree NumberTree collapseTree takes NumberTree returns Integer collapseTree (Leaf n) = n collapseTree (Branch n x y) n + (collapseTree x) + (collapseTree y) sampleTree = Branch 0 (Leaf 6) (Branch 1 (Leaf 2) (Leaf 9)) collapsedSample = collapseTree sampleTree Note that in the pattern collapseTree (Branch n x y) , the function calls upon itself to collapse the subtrees x and y . OcellusScript support different types of recursion and allows for this kind of behavior. Optional Types \u00b6 OcellusScript also support types that may contain a specific type of value or Nothing . These types, known as optionals , are often used in cases where the type of data being returned is unclear. Optional types are denoted by ? at the end of the type. For instance, the following function getDefaultHealth will return an integer or a default value if Nothing is received. getDefaultHealth takes Integer? returns Integer getDefaultHealth health = health ?? 100 The ?? operator in the expression indicates that the following value should be used if the preceding value is of type Nothing . Similarly, this function can be rewritten using pattern matching to make this clearer: getDefaultHealth takes Integer? returns Integer getDefaultHealth Nothing = 100 getDefaultHealth health = health Currently, functions that use optional types must account for when a type returns Nothing instead of the intended value and does not support force unwrapping. However, this behavior can be replicated (if desired) with a sample utility function like the one below: datatype ForcedValue = Anything or Error forceUnwrap takes Anything? returns ForcedValue forceUnrwap value = value ?? Error \"Cannot unwrap value Nothing.\"","title":"Custom Types and Optionals"},{"location":"language/05-types/#custom-types-and-optionals","text":"OcellusScript supports writing custom data types and types that inherit basic types. This can often be used to represent trees or a specific type of data. The type function can be used to define a new type that is inherited from any of the basic types : type Side = Float type Radius = Float Where Side and Radius is a type that is inherited from the Float type. Likewise, defining custom data types is accomplished with the datatype function: datatype Shape = Rectangle Side Side or Ellipse Radius Radius Where Shape can now either be a data type of Rectangle with parameters Side and Side or a data type of Ellipse with parameters Radius and Radius . Naming Types Custom types and datatype structures must always be named in Pascal case ( PascalCase ) to avoid confusion with other functions and keywords. OcellusScript will work with custom types and data types as standard types in functions, which is useful in pattern matching cases. The following area function matches across different type patterns to calculate a shape's area: area takes Shape returns Float area (Rectangle x y) = x * y area (Ellipse r q) = pi * r * q Data types are often useful for creating custom types with specific attributes or for creating tree-like structures. For instance, the following code includes a custom tree data type and a function to collapse a tree into a single value with pattern matching: datatype NumberTree = Leaf Integer or Branch Integer NumberTree NumberTree collapseTree takes NumberTree returns Integer collapseTree (Leaf n) = n collapseTree (Branch n x y) n + (collapseTree x) + (collapseTree y) sampleTree = Branch 0 (Leaf 6) (Branch 1 (Leaf 2) (Leaf 9)) collapsedSample = collapseTree sampleTree Note that in the pattern collapseTree (Branch n x y) , the function calls upon itself to collapse the subtrees x and y . OcellusScript support different types of recursion and allows for this kind of behavior.","title":"Custom Types and Optionals"},{"location":"language/05-types/#optional-types","text":"OcellusScript also support types that may contain a specific type of value or Nothing . These types, known as optionals , are often used in cases where the type of data being returned is unclear. Optional types are denoted by ? at the end of the type. For instance, the following function getDefaultHealth will return an integer or a default value if Nothing is received. getDefaultHealth takes Integer? returns Integer getDefaultHealth health = health ?? 100 The ?? operator in the expression indicates that the following value should be used if the preceding value is of type Nothing . Similarly, this function can be rewritten using pattern matching to make this clearer: getDefaultHealth takes Integer? returns Integer getDefaultHealth Nothing = 100 getDefaultHealth health = health Currently, functions that use optional types must account for when a type returns Nothing instead of the intended value and does not support force unwrapping. However, this behavior can be replicated (if desired) with a sample utility function like the one below: datatype ForcedValue = Anything or Error forceUnwrap takes Anything? returns ForcedValue forceUnrwap value = value ?? Error \"Cannot unwrap value Nothing.\"","title":"Optional Types"},{"location":"language/06-recursion/","text":"Recursion \u00b6 OcellusScript supports different types of recursion and are relatively easy to implement. The most typical form of recursion used in OcellusScript is linear recursion and works by processing a single element and constantly working on elements until the innermost element returns a single value. Elements then work upwards to \"collapse\" the work into a single evaluation. For instance, the following function below will keep working until the element value in question is divisible by 2: myEquation takes Integer returns Integer myEquation n = n % 2 == 0 ? n + 5 : myEquation (n * 2) The following would be how OcellusScript processes myEquation with the input parameter being 5 : Start with myEquation n where n = 5. Check if n is divisible by 2. n is NOT divisible by 2, so we multiply n by 2. New n = 10. Evaluate myEquation where n = 10. Check if n is divisible by 2. n IS divisible by 2, so we evaluate n + 5. n + 5 is 15. Return back value 15. Evaluation returns 15. Evaluation returns 15. where Expression \u00b6 Sometimes, it might be impractical to work with recursion and pattern matching all in a single function. To mitigate this, a helper function can be defined with the where expression. The following function reverse uses the where expression to write a pattern matching function that then can get used recursively. reverse takes String returns String reverse word = reverseHelper word \"\" where reverseHelper [] newWord = newWord reverseHelper character newWord = newWord + [character] reverseHelper (firstChar : otherChars) = reverseHelper otherChars (newWord + [firstChar]) The helper function reverseHelper gets called recursively when dealing with strings of more than one character in length and will transfer the letters over to newWord . After evaluating reverseHelper , the return value is returned to the original function. The where expression can be used to define a function preceding it or a specific value and is often used in cases of tail recursion or when pattern matching is needed. Note that the type signature for reverse does not include the signature for reverseHelper as it is not required.","title":"Recursion"},{"location":"language/06-recursion/#recursion","text":"OcellusScript supports different types of recursion and are relatively easy to implement. The most typical form of recursion used in OcellusScript is linear recursion and works by processing a single element and constantly working on elements until the innermost element returns a single value. Elements then work upwards to \"collapse\" the work into a single evaluation. For instance, the following function below will keep working until the element value in question is divisible by 2: myEquation takes Integer returns Integer myEquation n = n % 2 == 0 ? n + 5 : myEquation (n * 2) The following would be how OcellusScript processes myEquation with the input parameter being 5 : Start with myEquation n where n = 5. Check if n is divisible by 2. n is NOT divisible by 2, so we multiply n by 2. New n = 10. Evaluate myEquation where n = 10. Check if n is divisible by 2. n IS divisible by 2, so we evaluate n + 5. n + 5 is 15. Return back value 15. Evaluation returns 15. Evaluation returns 15.","title":"Recursion"},{"location":"language/06-recursion/#where-expression","text":"Sometimes, it might be impractical to work with recursion and pattern matching all in a single function. To mitigate this, a helper function can be defined with the where expression. The following function reverse uses the where expression to write a pattern matching function that then can get used recursively. reverse takes String returns String reverse word = reverseHelper word \"\" where reverseHelper [] newWord = newWord reverseHelper character newWord = newWord + [character] reverseHelper (firstChar : otherChars) = reverseHelper otherChars (newWord + [firstChar]) The helper function reverseHelper gets called recursively when dealing with strings of more than one character in length and will transfer the letters over to newWord . After evaluating reverseHelper , the return value is returned to the original function. The where expression can be used to define a function preceding it or a specific value and is often used in cases of tail recursion or when pattern matching is needed. Note that the type signature for reverse does not include the signature for reverseHelper as it is not required.","title":"where Expression"},{"location":"language/07-hoc/","text":"Higher-order Functions and Lambda Expressions \u00b6 OcellusScript supports writing functions that will accept functions as parameters. These functions, called higher-order functions, will usually take a function as one of its inputs or return a function as its output. OcellusScript comes with some built-in higher-order functions for use with iteration and lists. for \u00b6 The for function takes three inputs: a starting value, and ending value, and a callable function to run. The callable function can be written by any means and supports the where expression. An example of the for function is provided with the countToTen example where a number is logged through each iteration. countToTen takes Nothing returns Nothing countToTen = for 0 10 task where task i = log i It important to note that the for function will automatically take care of increasing the start value and decreasing the end value. The following is an implementation of the for function: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing for start end task = forHelper start start end task where forHelper i n j t = j == n ? t : forHelper (i + 1) n (j - 1) t map \u00b6 The map function is a utility function that returns a list with a function applied to its elements. It accepts two parameters: the callable function to run on each element, and the list of items to run the callable function on. The following mapIfTwo function makes use of map to change a list of numbers into a list of booleans based on their divisibility: divisibleByTwo takes Integer returns Boolean divisibleByTwo num = num % 2 == 0 mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map divisibleByTwo list Note that the divisibleByTwo function does not get called in the mapIfTwo definition as map will automatically handle this. Below is the implementation for map : map takes (Callable takes Anything returns Anything) and [Anything] \\ returns [Anything] map func x = helper func x [] where helper func [] list = list helper func i list = list + [func i] helper func (i:j) list = helper func j (list + [func i]) filter \u00b6 The filter function is a utility function that returns a list of items that obey a following condition. It accepts two parameters: the callable function that determines whether an item will be in the new list, and the list to filter. The following containsBan function makes use of filter to filter out any words in the list that do not contain the letters b, a, or n: banHelper takes String returns Boolean banHelper [] = true banHelper x = member x \"ban\" banHelper (x : xs) = (member x \"ban\") and (banHelper xs) containsBan takes [String] returns [String] containsBan list = filter banHelper list Again, note that banHelper does not get called in containsBan as filter handles this automatically. Below is the implementation for filter : filter takes (Callable takes Anything returns Boolean) and [Anything] \\ returns [Anything] filter f x = helper f x [] where helper func [] list = list helper func i list = (func i) ? list + [i] : list helper func (i:j) list = helper func j (func i) ? list + [i] : list) reduce \u00b6 The reduce function is a utility function that returns a single value of type Anything based on a method of reduction. It accepts three parameters: the callable function that dictates how values will be combined, the list to combine into a single value, and the starting value. The starting value will dictate what type the reduce function returns. The following smartAdd functions makes uses of reduce to add according to a specific set of rules: smartAdditionHelper takes Integer and Integer returns Integer smartAdditionHelper x y = y % 3 == 0 ? x + (y * 4) : x + y smartAdd takes [Integer] returns Integer smartAdd list = reduce smartAdditionHelper list 0 Again, note that smartAdditionHelper is not called inside of the smartAdd function as reduce calls this automatically when running. Below is the implementation for reduce : reduce takes (Callable takes Anything and Anything returns Anything) \\ and [Anything] and Anything returns Anything reduce f x s = helper f x s where helper combinator [] s = s helper combinator i s = combinator i s helper combinator (i:j) s = helper combinator j (combinator i s) Lambda Functions \u00b6 Sometimes it doesn't make sense to write a separate function to pass into a higher-order function like map . The lambda function is an in-line function that returns a function that evaluates a single expression from a select amount of parameters. The following example reduces the amount of code in mapIfTwo to use a lambda: mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map (lambda x -> x % 2 == 0) list This can also be used in cases like the for function: countToFive takes Nothing returns Nothing countToFive = for 0 5 (lambda x -> log x)","title":"Higher-order Functions and Lambda Expressions"},{"location":"language/07-hoc/#higher-order-functions-and-lambda-expressions","text":"OcellusScript supports writing functions that will accept functions as parameters. These functions, called higher-order functions, will usually take a function as one of its inputs or return a function as its output. OcellusScript comes with some built-in higher-order functions for use with iteration and lists.","title":"Higher-order Functions and Lambda Expressions"},{"location":"language/07-hoc/#for","text":"The for function takes three inputs: a starting value, and ending value, and a callable function to run. The callable function can be written by any means and supports the where expression. An example of the for function is provided with the countToTen example where a number is logged through each iteration. countToTen takes Nothing returns Nothing countToTen = for 0 10 task where task i = log i It important to note that the for function will automatically take care of increasing the start value and decreasing the end value. The following is an implementation of the for function: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing for start end task = forHelper start start end task where forHelper i n j t = j == n ? t : forHelper (i + 1) n (j - 1) t","title":"for"},{"location":"language/07-hoc/#map","text":"The map function is a utility function that returns a list with a function applied to its elements. It accepts two parameters: the callable function to run on each element, and the list of items to run the callable function on. The following mapIfTwo function makes use of map to change a list of numbers into a list of booleans based on their divisibility: divisibleByTwo takes Integer returns Boolean divisibleByTwo num = num % 2 == 0 mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map divisibleByTwo list Note that the divisibleByTwo function does not get called in the mapIfTwo definition as map will automatically handle this. Below is the implementation for map : map takes (Callable takes Anything returns Anything) and [Anything] \\ returns [Anything] map func x = helper func x [] where helper func [] list = list helper func i list = list + [func i] helper func (i:j) list = helper func j (list + [func i])","title":"map"},{"location":"language/07-hoc/#filter","text":"The filter function is a utility function that returns a list of items that obey a following condition. It accepts two parameters: the callable function that determines whether an item will be in the new list, and the list to filter. The following containsBan function makes use of filter to filter out any words in the list that do not contain the letters b, a, or n: banHelper takes String returns Boolean banHelper [] = true banHelper x = member x \"ban\" banHelper (x : xs) = (member x \"ban\") and (banHelper xs) containsBan takes [String] returns [String] containsBan list = filter banHelper list Again, note that banHelper does not get called in containsBan as filter handles this automatically. Below is the implementation for filter : filter takes (Callable takes Anything returns Boolean) and [Anything] \\ returns [Anything] filter f x = helper f x [] where helper func [] list = list helper func i list = (func i) ? list + [i] : list helper func (i:j) list = helper func j (func i) ? list + [i] : list)","title":"filter"},{"location":"language/07-hoc/#reduce","text":"The reduce function is a utility function that returns a single value of type Anything based on a method of reduction. It accepts three parameters: the callable function that dictates how values will be combined, the list to combine into a single value, and the starting value. The starting value will dictate what type the reduce function returns. The following smartAdd functions makes uses of reduce to add according to a specific set of rules: smartAdditionHelper takes Integer and Integer returns Integer smartAdditionHelper x y = y % 3 == 0 ? x + (y * 4) : x + y smartAdd takes [Integer] returns Integer smartAdd list = reduce smartAdditionHelper list 0 Again, note that smartAdditionHelper is not called inside of the smartAdd function as reduce calls this automatically when running. Below is the implementation for reduce : reduce takes (Callable takes Anything and Anything returns Anything) \\ and [Anything] and Anything returns Anything reduce f x s = helper f x s where helper combinator [] s = s helper combinator i s = combinator i s helper combinator (i:j) s = helper combinator j (combinator i s)","title":"reduce"},{"location":"language/07-hoc/#lambda-functions","text":"Sometimes it doesn't make sense to write a separate function to pass into a higher-order function like map . The lambda function is an in-line function that returns a function that evaluates a single expression from a select amount of parameters. The following example reduces the amount of code in mapIfTwo to use a lambda: mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map (lambda x -> x % 2 == 0) list This can also be used in cases like the for function: countToFive takes Nothing returns Nothing countToFive = for 0 5 (lambda x -> log x)","title":"Lambda Functions"},{"location":"language/08-error/","text":"Error Handling \u00b6 There may be functions that are defined in OcellusScript that might return an Error type and stop program flow. As a way to gracefully handle errors, the ternary-like ! operator syntax can be used. The following example code works with the forced unwrapped value code from the Optional Types section to handle error handling: addForcedValues takes ForcedValue returns Integer? addForcedValues x = (forceUnwrap x) ! x + 5 : log \"Couldn't unwrap value x\"","title":"Error Handling"},{"location":"language/08-error/#error-handling","text":"There may be functions that are defined in OcellusScript that might return an Error type and stop program flow. As a way to gracefully handle errors, the ternary-like ! operator syntax can be used. The following example code works with the forced unwrapped value code from the Optional Types section to handle error handling: addForcedValues takes ForcedValue returns Integer? addForcedValues x = (forceUnwrap x) ! x + 5 : log \"Couldn't unwrap value x\"","title":"Error Handling"},{"location":"language/09-modules/","text":"Modules and Main Execution \u00b6 OcellusScript works on a file-based level and supports creating and importing modules that contain other functions and utilities. When an OcellusScript file is written, it is considered a module in and of itself when the module function is defined. The following example in the file vill.ocls shows how a module is written: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) vill.ocls is a typical OcellusScript file, but because the module function is defined at the top, all functions and types in this file are publicly accessible to other OcellusScript files by importing VillainDatabase . For example, another file called chr.ocls can make use of everything inside this module by using the import function: import VillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Specific imports \u00b6 Importing the entire module may not be necessary and could cost performance. OcellusScript can handle this with specific imports. Again, with chr.ocls , we can manually import the inVillainDatabase function without importing everything else with the only statement: import VillainDatabase only inVillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Likewise, except will import the entire module except a specific function: import VillainDatabase except knownByReform foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Private functions \u00b6 Modules expose every function and type in a file and make it publicly accessible, which may not be desired. To mitigate this, adding the keyword private in front of a function definition will make sure that the function does not get imported when the module is imported. Looking back at vill.ocls , we could probably make the knownVillains function private so, say, a villain can't delete their entry from the database: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] private knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) Note that the private keyword does not need to be in the type signature of the function. Documentation Strings and Comments \u00b6 It's good practice to include documentation with your source code. Documentation often provides information on what a function will do or what a module contains. Documentation strings (docstrings) are denoted with a set of backticks (```) can be inserted between a type signature and a function definition like below: inVillainDatabase takes String returns Boolean `Check whether a villain is in the known villain database. Arguments: name: The name of the person to search for. ` inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) If you want to write comments or notes in a file, you can use a single hash ( # ) and then keep typing. OcellusScript will not execute any code in triple-quotes or after a hash. Comments with a hash extend until the next line in a file. To access documentation for a function, the help function can be called: help inVillainDatabase Where help accepts a single parameter, the callable function with a docstring. If no documentation is found, nothing is returned. Executing a File \u00b6 Thus far, we've defined functions in OcellusScript but haven't quite interacted with them. There are two ways to interact with them: Importing the module into an interactive interpreter environment Defining a main function that will be executed when running a compiled version of a script OcellusScript supports the main function to write a function that executes when you call on a file's executable: import VillainDatabase main args = log (inVillainDatabase \"Twilight\") When the file above is run after compiling, the main function will be executed. The following is the type signature of the main function: main takes [String?] returns Anything? When the file is executed, it can take in parameters from the command line as parameters to main .","title":"Modules and Main Execution"},{"location":"language/09-modules/#modules-and-main-execution","text":"OcellusScript works on a file-based level and supports creating and importing modules that contain other functions and utilities. When an OcellusScript file is written, it is considered a module in and of itself when the module function is defined. The following example in the file vill.ocls shows how a module is written: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) vill.ocls is a typical OcellusScript file, but because the module function is defined at the top, all functions and types in this file are publicly accessible to other OcellusScript files by importing VillainDatabase . For example, another file called chr.ocls can make use of everything inside this module by using the import function: import VillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\"","title":"Modules and Main Execution"},{"location":"language/09-modules/#specific-imports","text":"Importing the entire module may not be necessary and could cost performance. OcellusScript can handle this with specific imports. Again, with chr.ocls , we can manually import the inVillainDatabase function without importing everything else with the only statement: import VillainDatabase only inVillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\" Likewise, except will import the entire module except a specific function: import VillainDatabase except knownByReform foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase \"Chrysalis\"","title":"Specific imports"},{"location":"language/09-modules/#private-functions","text":"Modules expose every function and type in a file and make it publicly accessible, which may not be desired. To mitigate this, adding the keyword private in front of a function definition will make sure that the function does not get imported when the module is imported. Looking back at vill.ocls , we could probably make the knownVillains function private so, say, a villain can't delete their entry from the database: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] private knownVillains = [(Villain \"Nightmare Moon\" true), (Villain \"Discord\" true), (Villain \"Tirek\" false), (Villain \"Tempest Shadow\" false), (Villain \"Starlight Glimmer\" false), (Villain \"Chrysalis\" false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) -> reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) Note that the private keyword does not need to be in the type signature of the function.","title":"Private functions"},{"location":"language/09-modules/#documentation-strings-and-comments","text":"It's good practice to include documentation with your source code. Documentation often provides information on what a function will do or what a module contains. Documentation strings (docstrings) are denoted with a set of backticks (```) can be inserted between a type signature and a function definition like below: inVillainDatabase takes String returns Boolean `Check whether a villain is in the known villain database. Arguments: name: The name of the person to search for. ` inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) If you want to write comments or notes in a file, you can use a single hash ( # ) and then keep typing. OcellusScript will not execute any code in triple-quotes or after a hash. Comments with a hash extend until the next line in a file. To access documentation for a function, the help function can be called: help inVillainDatabase Where help accepts a single parameter, the callable function with a docstring. If no documentation is found, nothing is returned.","title":"Documentation Strings and Comments"},{"location":"language/09-modules/#executing-a-file","text":"Thus far, we've defined functions in OcellusScript but haven't quite interacted with them. There are two ways to interact with them: Importing the module into an interactive interpreter environment Defining a main function that will be executed when running a compiled version of a script OcellusScript supports the main function to write a function that executes when you call on a file's executable: import VillainDatabase main args = log (inVillainDatabase \"Twilight\") When the file above is run after compiling, the main function will be executed. The following is the type signature of the main function: main takes [String?] returns Anything? When the file is executed, it can take in parameters from the command line as parameters to main .","title":"Executing a File"},{"location":"language/10-style/","text":"Stylebook \u00b6 While it isn't functionally necessary to follow the OcellusScript style guidelines, these guidelines can help make your code more readable and easier to understand. Keep Lines Short \u00b6 A line in OcellusScript should be no more than 100 characters in length so that it can be opened and read easily without the need for text-wrapping. Always Include Type Signatures and Docstrings \u00b6 Type signatures and docstrings are completely optional, but should be included to reduce confusion of input and output types, as well as providing sufficient documentation that can be called with help . Use Consistent Indentation \u00b6 OcellusScript files should use space indents with a length of four spaces per indent. Separate Long Lines \u00b6 Longer lines should be separated into smaller lines to make the code easy to read and traverse. The following provides cases where lines should be split. On Conditional Expressions \u00b6 While it is possible to do an in-line ternary operator for a conditional, if the condition evaluation is lengthy, consider putting them on separate lines: doStuff takes Integer returns Integer doStuff x = x % 5 == 1 ? x + 13 : x + 5 On Operators and Lists \u00b6 type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name myList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")] On Parameters and Functions \u00b6 inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains) Using \\ Separator \u00b6 If needed, the \\ operator at the end of a line can be used to break up other components like type signatures: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing On Functions Defined with where \u00b6 When possible, functions that use the where syntax to be defined on the next lines should be indented: printLetters takes String returns Nothing printLetters string = for 0 (length string) task where task i = log string[i] Declare Private Functions and Types Before Functions \u00b6 When possible, any custom types, data types, and private functions should go before public functions: module Equestria where type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name private testList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")] main args = log \"Imported!\"","title":"Stylebook"},{"location":"language/10-style/#stylebook","text":"While it isn't functionally necessary to follow the OcellusScript style guidelines, these guidelines can help make your code more readable and easier to understand.","title":"Stylebook"},{"location":"language/10-style/#keep-lines-short","text":"A line in OcellusScript should be no more than 100 characters in length so that it can be opened and read easily without the need for text-wrapping.","title":"Keep Lines Short"},{"location":"language/10-style/#always-include-type-signatures-and-docstrings","text":"Type signatures and docstrings are completely optional, but should be included to reduce confusion of input and output types, as well as providing sufficient documentation that can be called with help .","title":"Always Include Type Signatures and Docstrings"},{"location":"language/10-style/#use-consistent-indentation","text":"OcellusScript files should use space indents with a length of four spaces per indent.","title":"Use Consistent Indentation"},{"location":"language/10-style/#separate-long-lines","text":"Longer lines should be separated into smaller lines to make the code easy to read and traverse. The following provides cases where lines should be split.","title":"Separate Long Lines"},{"location":"language/10-style/#on-conditional-expressions","text":"While it is possible to do an in-line ternary operator for a conditional, if the condition evaluation is lengthy, consider putting them on separate lines: doStuff takes Integer returns Integer doStuff x = x % 5 == 1 ? x + 13 : x + 5","title":"On Conditional Expressions"},{"location":"language/10-style/#on-operators-and-lists","text":"type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name myList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")]","title":"On Operators and Lists"},{"location":"language/10-style/#on-parameters-and-functions","text":"inVillainDatabase name = member name (map (lambda (Villain name _ ) -> name) knownVillains)","title":"On Parameters and Functions"},{"location":"language/10-style/#using-separator","text":"If needed, the \\ operator at the end of a line can be used to break up other components like type signatures: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing","title":"Using \\ Separator"},{"location":"language/10-style/#on-functions-defined-with-where","text":"When possible, functions that use the where syntax to be defined on the next lines should be indented: printLetters takes String returns Nothing printLetters string = for 0 (length string) task where task i = log string[i]","title":"On Functions Defined with where"},{"location":"language/10-style/#declare-private-functions-and-types-before-functions","text":"When possible, any custom types, data types, and private functions should go before public functions: module Equestria where type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name private testList = [(Changeling \"Ocellus\"), (Pony \"Twilight\"), (Zebra \"Zecora\")] main args = log \"Imported!\"","title":"Declare Private Functions and Types Before Functions"},{"location":"language/11-spec/","text":"Specification \u00b6 The following page is the specification for the OcellusScript language and contains technical information such as lexical elements, program structure, and parsing grammars. Developers using OcellusScript don't need to be too concerned with the specification, but this document is useful for those wishing to write an implementation of the OcellusScript specification, either as a compiler/interpreter for OcellusScript or or as a new language that stems from this spec. Lexical Elements \u00b6 During the tokenization process, OcellusScript will create tokens of the following types: Keyword refers to any of the primary keywords such as types, statements, and values. Identifier refers to a group of uppercase and lowercase letters. StringConstant refers to a string containing valid Unicode characters, excluding double quotes (unless escaped). DocstringConstant refers to a documentation string containing valid Unicode characters that start and end with a back tick (`). CommentConstant refers to a comment containing valid Unicode characters that start with the hash symbol ( # ) and end with a newline character ( \\n ). Symbol refers to any non-alphanumeric characters. IntConstant refers to any integers that do not contain a decimal point. FloatConstant refers to a number that contains a single decimal point. LineReturn refers to a newline character ( \\n ). Below are the lists containing valid keywords, symbols, operators, etc. Type Classified Elements Keyword Character , String , Integer , Boolean , Float , Callable , Anything , Nothing , Error , import , module , where , takes , returns , log , only , except , warn , true , false , type , datatype , private , and , or , not Symbol < , > , , , ? , [ , ] , ( , ) , - , = , + , * , / , % , \\ , ! , : , # Notes on Lexical Elements \u00b6 CommentConstant is not required to be listed or parsed and can be removed, if necessary. Grammar Structure \u00b6 OcellusScript uses the following grammar set to define functions, expressions, types, etc. when parsing a list of tokens. Grammars with a pipe character ( | ) indicate an 'or' option, grammars with ? will mean optional, and grammars with * will mean a group with zero or more of that particular group. Modules \u00b6 Grammar module := (importStatement)* (module Identifier where)? (fnDef | dataDef | typeDef)* importStatement := import Identifier ((except | only) Identifier (, Identifier)*)? Module Names \u00b6 In cases where there isn't a module statement in the file or script, a random name is assigned and the module is marked as not importable. Otherwise, the module's name will be assigned from the module statement and will be marked as importable. Import Statements \u00b6 When import statements are parsed, the import names in the abstract syntax tree will be represented in three ways: Module.* , when importing the entire module Module.specific , when importing specific from Module Module!specific , when importing the entire module except for specific Custom Types and Datatypes \u00b6 Grammar dataDef := datatype Identifier = dataStructDef (or dataStructDef)* dataStructDef := (Identifier (Identifier | Keyword)*) typeDef := type Identifier = Keyword Identifiers in Datatypes and Custom Types \u00b6 OcellusScript requires that the identifiers used to define custom datatypes and types be written in PascalCase to prevent possible confusion with other functions. Functions \u00b6 Grammar fnDef := (fnSignature)? (Docstring)? fnBody (fnBody)* fnSignature := Identifier takes (fnSignatureType)* returns fnSignatureType fnSignatureType := [Identifier | Keyword] | Identifier|Keyword(?)? | (fnSignature) fnBody := Identifier (fnParam)* = (fnResult) fnParam := Identifier | fnLikeData | fnWithCons fnLikeData := (Identifier (Identifier | Keyword | IntConstant | StringConstant)*) fnWithCons := (Identifier : Identifier (: Identifier)*) fnResult := expression* Expressions \u00b6 Grammar expression := boolExpr | expression boolExpr := equExpr (and | or) equExpr | not equExpr | equExpr equExpr := lowIneqExpr ((! | =)=) lowIneqExpr | lowIneqExpr lowIneqExpr := highIneqExpr ((> | <)=) highIneqExpr | highIneqExpr highIneqExpr := addExpr (> | <) addExpr | addExpr addExpr := multExpr (+ | -) multExpr | multExpr multExpr := term (* | / | %) term | term term := (expression) | Identifier | StringConstant | IntConstant | keyConst | FloatConstant | list keyConst := true | false | Anything | Nothing list := [term (, term)*] Syntax Tree \u00b6 The following provides the overall structure of what the abstract syntax tree looks like. Modules \u00b6 { \"module\" : { \"name\" : \"Example\" , \"importable\" : true , \"depends\" : [ \"Hive.*\" ], \"types\" : {}, \"datatypes\" : {}, \"functions\" : [] } } Custom Types \u00b6 \"type\" : { \"name\" : \"Example\" , \"shadows\" : \"Boolean\" } Custom Datatypes \u00b6 \"datatype\" : { \"name\" : \"Example\" , \"structures\" : [ \"( Example1 String Int )\" ] } Functions \u00b6 \"function\" : { \"name\" : \"exampleFn\" , \"signature\" : {}, \"docstring\" : \"\" , \"body\" : [] } Function Signature \u00b6 \"signature\" : { \"parameter_types\" : [ \"Example\" ], \"return\" : [ \"Example\" ] } Function Body \u00b6 \"body\" : [ { \"params\" : [ \"example\" ], \"result\" : {} } ] Expression \u00b6 \"expression\" : { \"operative_expression\" : { \"operation\" : null , \"left\" : {}, \"right\" : {} } } All expressions with operators follow the same basic pattern as operative_expression , but use different keys: boolean_expression equality_expression low_inequal_expression high_inequal_expression additive_expression multiplicative_expression The operation is then set in the operation key if there is an operation present. If nothing is present on either side of the tree's children, \"Nothing\" is put in place of that particular child. Term \u00b6 { \"identifier\" : \"Example\" } identifier can be replaced with the appropriate term type that matches the value of the type. See below for information on lists as pairs. List Pair \u00b6 \"list_constant\" : { \"head\" : {}, \"tail\" : {} }","title":"Specification"},{"location":"language/11-spec/#specification","text":"The following page is the specification for the OcellusScript language and contains technical information such as lexical elements, program structure, and parsing grammars. Developers using OcellusScript don't need to be too concerned with the specification, but this document is useful for those wishing to write an implementation of the OcellusScript specification, either as a compiler/interpreter for OcellusScript or or as a new language that stems from this spec.","title":"Specification"},{"location":"language/11-spec/#lexical-elements","text":"During the tokenization process, OcellusScript will create tokens of the following types: Keyword refers to any of the primary keywords such as types, statements, and values. Identifier refers to a group of uppercase and lowercase letters. StringConstant refers to a string containing valid Unicode characters, excluding double quotes (unless escaped). DocstringConstant refers to a documentation string containing valid Unicode characters that start and end with a back tick (`). CommentConstant refers to a comment containing valid Unicode characters that start with the hash symbol ( # ) and end with a newline character ( \\n ). Symbol refers to any non-alphanumeric characters. IntConstant refers to any integers that do not contain a decimal point. FloatConstant refers to a number that contains a single decimal point. LineReturn refers to a newline character ( \\n ). Below are the lists containing valid keywords, symbols, operators, etc. Type Classified Elements Keyword Character , String , Integer , Boolean , Float , Callable , Anything , Nothing , Error , import , module , where , takes , returns , log , only , except , warn , true , false , type , datatype , private , and , or , not Symbol < , > , , , ? , [ , ] , ( , ) , - , = , + , * , / , % , \\ , ! , : , #","title":"Lexical Elements"},{"location":"language/11-spec/#notes-on-lexical-elements","text":"CommentConstant is not required to be listed or parsed and can be removed, if necessary.","title":"Notes on Lexical Elements"},{"location":"language/11-spec/#grammar-structure","text":"OcellusScript uses the following grammar set to define functions, expressions, types, etc. when parsing a list of tokens. Grammars with a pipe character ( | ) indicate an 'or' option, grammars with ? will mean optional, and grammars with * will mean a group with zero or more of that particular group.","title":"Grammar Structure"},{"location":"language/11-spec/#modules","text":"Grammar module := (importStatement)* (module Identifier where)? (fnDef | dataDef | typeDef)* importStatement := import Identifier ((except | only) Identifier (, Identifier)*)?","title":"Modules"},{"location":"language/11-spec/#module-names","text":"In cases where there isn't a module statement in the file or script, a random name is assigned and the module is marked as not importable. Otherwise, the module's name will be assigned from the module statement and will be marked as importable.","title":"Module Names"},{"location":"language/11-spec/#import-statements","text":"When import statements are parsed, the import names in the abstract syntax tree will be represented in three ways: Module.* , when importing the entire module Module.specific , when importing specific from Module Module!specific , when importing the entire module except for specific","title":"Import Statements"},{"location":"language/11-spec/#custom-types-and-datatypes","text":"Grammar dataDef := datatype Identifier = dataStructDef (or dataStructDef)* dataStructDef := (Identifier (Identifier | Keyword)*) typeDef := type Identifier = Keyword","title":"Custom Types and Datatypes"},{"location":"language/11-spec/#identifiers-in-datatypes-and-custom-types","text":"OcellusScript requires that the identifiers used to define custom datatypes and types be written in PascalCase to prevent possible confusion with other functions.","title":"Identifiers in Datatypes and Custom Types"},{"location":"language/11-spec/#functions","text":"Grammar fnDef := (fnSignature)? (Docstring)? fnBody (fnBody)* fnSignature := Identifier takes (fnSignatureType)* returns fnSignatureType fnSignatureType := [Identifier | Keyword] | Identifier|Keyword(?)? | (fnSignature) fnBody := Identifier (fnParam)* = (fnResult) fnParam := Identifier | fnLikeData | fnWithCons fnLikeData := (Identifier (Identifier | Keyword | IntConstant | StringConstant)*) fnWithCons := (Identifier : Identifier (: Identifier)*) fnResult := expression*","title":"Functions"},{"location":"language/11-spec/#expressions","text":"Grammar expression := boolExpr | expression boolExpr := equExpr (and | or) equExpr | not equExpr | equExpr equExpr := lowIneqExpr ((! | =)=) lowIneqExpr | lowIneqExpr lowIneqExpr := highIneqExpr ((> | <)=) highIneqExpr | highIneqExpr highIneqExpr := addExpr (> | <) addExpr | addExpr addExpr := multExpr (+ | -) multExpr | multExpr multExpr := term (* | / | %) term | term term := (expression) | Identifier | StringConstant | IntConstant | keyConst | FloatConstant | list keyConst := true | false | Anything | Nothing list := [term (, term)*]","title":"Expressions"},{"location":"language/11-spec/#syntax-tree","text":"The following provides the overall structure of what the abstract syntax tree looks like.","title":"Syntax Tree"},{"location":"language/11-spec/#modules_1","text":"{ \"module\" : { \"name\" : \"Example\" , \"importable\" : true , \"depends\" : [ \"Hive.*\" ], \"types\" : {}, \"datatypes\" : {}, \"functions\" : [] } }","title":"Modules"},{"location":"language/11-spec/#custom-types","text":"\"type\" : { \"name\" : \"Example\" , \"shadows\" : \"Boolean\" }","title":"Custom Types"},{"location":"language/11-spec/#custom-datatypes","text":"\"datatype\" : { \"name\" : \"Example\" , \"structures\" : [ \"( Example1 String Int )\" ] }","title":"Custom Datatypes"},{"location":"language/11-spec/#functions_1","text":"\"function\" : { \"name\" : \"exampleFn\" , \"signature\" : {}, \"docstring\" : \"\" , \"body\" : [] }","title":"Functions"},{"location":"language/11-spec/#function-signature","text":"\"signature\" : { \"parameter_types\" : [ \"Example\" ], \"return\" : [ \"Example\" ] }","title":"Function Signature"},{"location":"language/11-spec/#function-body","text":"\"body\" : [ { \"params\" : [ \"example\" ], \"result\" : {} } ]","title":"Function Body"},{"location":"language/11-spec/#expression","text":"\"expression\" : { \"operative_expression\" : { \"operation\" : null , \"left\" : {}, \"right\" : {} } } All expressions with operators follow the same basic pattern as operative_expression , but use different keys: boolean_expression equality_expression low_inequal_expression high_inequal_expression additive_expression multiplicative_expression The operation is then set in the operation key if there is an operation present. If nothing is present on either side of the tree's children, \"Nothing\" is put in place of that particular child.","title":"Expression"},{"location":"language/11-spec/#term","text":"{ \"identifier\" : \"Example\" } identifier can be replaced with the appropriate term type that matches the value of the type. See below for information on lists as pairs.","title":"Term"},{"location":"language/11-spec/#list-pair","text":"\"list_constant\" : { \"head\" : {}, \"tail\" : {} }","title":"List Pair"}]}