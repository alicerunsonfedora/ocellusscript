{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OcellusScript A Haskell-inspired functional programming language OcellusScript is a simple functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel . It heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language. Quick start Warning Efficacy is still being developed and cannot be installed from PyPI yet. You can still download the source code and build it yourself to try it out. More information on the progress of Efficacy can be read on the current progress page. To get started with writing OcellusScript code, install the Efficacy tools using pip: pip install efficacy To try compiling an example, download an example file and run the compiler: efficacy -i filename .ocls -o example","title":"OcellusScript"},{"location":"#ocellusscript","text":"","title":"OcellusScript"},{"location":"#a-haskell-inspired-functional-programming-language","text":"OcellusScript is a simple functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel . It heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language.","title":"A Haskell-inspired functional programming language"},{"location":"#quick-start","text":"Warning Efficacy is still being developed and cannot be installed from PyPI yet. You can still download the source code and build it yourself to try it out. More information on the progress of Efficacy can be read on the current progress page. To get started with writing OcellusScript code, install the Efficacy tools using pip: pip install efficacy To try compiling an example, download an example file and run the compiler: efficacy -i filename .ocls -o example","title":"Quick start"},{"location":"progress/","text":"Current Progress Warning OcellusScript is a work-in-progress language, so not all components of OcellusScript are functional. Below is a running checklist of what has been completed and what still needs to be worked on. Language Specification The language specification checklist contains all of the necessary information on how OcellusScript is defined as a language. This includes lexical elements, grammars, evaluations, etc. Lexical elements Language grammar structure Module grammars Custom type/datatype grammars Function definition grammars Expression grammars Function call grammars Note Language grammars may be updated as Efficacy's parser is developed to better represent itself. Efficacy Efficacy is the official tokenizer, parser, compiler and interpreter for OcellusScript. Tokenizer Parser Modules Custom types Custom datatypes Basic expressions Function calls Conditional and null expressions Function definitions Pattern matching Lambda expressions Compiler Command Line Reading input files Creating token JSON files Creating abstract syntax tree JSON files Creating compiled files Interactive environment Modules Hive","title":"Current Progress"},{"location":"progress/#current-progress","text":"Warning OcellusScript is a work-in-progress language, so not all components of OcellusScript are functional. Below is a running checklist of what has been completed and what still needs to be worked on.","title":"Current Progress"},{"location":"progress/#language-specification","text":"The language specification checklist contains all of the necessary information on how OcellusScript is defined as a language. This includes lexical elements, grammars, evaluations, etc. Lexical elements Language grammar structure Module grammars Custom type/datatype grammars Function definition grammars Expression grammars Function call grammars Note Language grammars may be updated as Efficacy's parser is developed to better represent itself.","title":"Language Specification"},{"location":"progress/#efficacy","text":"Efficacy is the official tokenizer, parser, compiler and interpreter for OcellusScript. Tokenizer Parser Modules Custom types Custom datatypes Basic expressions Function calls Conditional and null expressions Function definitions Pattern matching Lambda expressions Compiler Command Line Reading input files Creating token JSON files Creating abstract syntax tree JSON files Creating compiled files Interactive environment Modules Hive","title":"Efficacy"},{"location":"vscode/","text":"VS Code Extension The OcellusScript extension for Visual Studio code offers syntax highlighting support for OcellusScript files and includes snippets for writing pieces of code faster. Getting started To add this extension to your Visual Studio Code installation, search for it in the Visual Studio Marketplace and install the extension. Alternatively, you can clone the GitHub repository and install the extension to your extensions folder: git clone https://github.com/alicerunsonfedora/ocellusscript-vscode ~/.vscode/extensions/net.marquiskurt.ocellusscript-lang Snippets The following snippets are available out-of-the-box when installing this extension: mapf : Writes out the map higher-order function . filterf : Writes out the filter higher-order function . reducef : Writes out the map higher-order function . forf : Writes out the for higher-order function . lmbd : Writes out a boilerplate lambda expression . ifcond : Writes out a boilerplate for a conditional expression . mname : Writes out a boilerplate for a module declaration . dtype : Writes out a boilerplate for a datatype declaration .","title":"VS Code Extension"},{"location":"vscode/#vs-code-extension","text":"The OcellusScript extension for Visual Studio code offers syntax highlighting support for OcellusScript files and includes snippets for writing pieces of code faster.","title":"VS Code Extension"},{"location":"vscode/#getting-started","text":"To add this extension to your Visual Studio Code installation, search for it in the Visual Studio Marketplace and install the extension. Alternatively, you can clone the GitHub repository and install the extension to your extensions folder: git clone https://github.com/alicerunsonfedora/ocellusscript-vscode ~/.vscode/extensions/net.marquiskurt.ocellusscript-lang","title":"Getting started"},{"location":"vscode/#snippets","text":"The following snippets are available out-of-the-box when installing this extension: mapf : Writes out the map higher-order function . filterf : Writes out the filter higher-order function . reducef : Writes out the map higher-order function . forf : Writes out the for higher-order function . lmbd : Writes out a boilerplate lambda expression . ifcond : Writes out a boilerplate for a conditional expression . mname : Writes out a boilerplate for a module declaration . dtype : Writes out a boilerplate for a datatype declaration .","title":"Snippets"},{"location":"efficacy/","text":"Welcome to Efficacy Efficacy is the official lexer, parser, compiler, and interactive interpreter for the OcellusScript language. Efficacy can be installed as a command-line program or can be imported into Python scripts as a Python module. Efficacy currently supports Python 2.7.16 and Python 3.7+. Use Python 3 It is highly recommended that you do not use Efficacy with Python 2.7. Support for 2.7 is included only for projects that cannot be upgraded to Python 3 and is only a compatibility solution. Getting Started Efficacy can be installed in a Python environment using pip: pip install efficacy Alternatively, Efficacy can be added as a dependency to a Poetry project: poetry add efficacy; poetry update Table of Contents Usage Module","title":"Welcome <small>to Efficacy</small>"},{"location":"efficacy/#welcome-to-efficacy","text":"Efficacy is the official lexer, parser, compiler, and interactive interpreter for the OcellusScript language. Efficacy can be installed as a command-line program or can be imported into Python scripts as a Python module. Efficacy currently supports Python 2.7.16 and Python 3.7+. Use Python 3 It is highly recommended that you do not use Efficacy with Python 2.7. Support for 2.7 is included only for projects that cannot be upgraded to Python 3 and is only a compatibility solution.","title":"Welcome to Efficacy"},{"location":"efficacy/#getting-started","text":"Efficacy can be installed in a Python environment using pip: pip install efficacy Alternatively, Efficacy can be added as a dependency to a Poetry project: poetry add efficacy; poetry update","title":"Getting Started"},{"location":"efficacy/#table-of-contents","text":"Usage Module","title":"Table of Contents"},{"location":"efficacy/01-cli/","text":"Using Efficacy CLI The Efficacy compiler and interactive environment can be called from the terminal by running efficacy . Arguments The following are arguments that can be passed to Efficacy to specify details. Running Efficacy without any arguments opens the interactive mode. Argument Full Argument Required Description -i --input No 1 The path to the input file to compile -o --output No The path to where the compiled executable will be placed -oT --output-tokens No The path to where the token file will be placed -oA --output-abstract-tree No The path to where the abstract tree file will be placed Creating a Token File Efficacy supports creating a JSON file containing the tokens it discovered while tokenizing the input file. It mainly contains a list of objects with the token type (see Lexical Elements ) and the token itself. This token file is useful when comparing a lexer's ability to tokenize an OcellusScript file to Efficacy's lexer, OSTokenizer . Example [ { Identifier : x }, { Symbol : = }, { Identifier : x }, { Symbol : + }, { IntConstant : 5 }, ] Creating an Abstract Syntax Tree File Efficacy also supports creating a JSON file that represents the parsed abstract syntax tree from the input file. This contains a tree structure as described in the language specification , which may be useful for comparing a custom parser with Efficacy's OSParser . Example { module : { name : Example , importable : true , depends : [ Hive.* ], types : [], datatypes : [], functions : [ { function : { name : test , signature : {}, docstring : , body : [ { params : [], result : { expression : { ... } } } ] } } ] } } The input argument is required when compiling files or preparing a tokenized or parsed JSON file.","title":"Using Efficacy CLI"},{"location":"efficacy/01-cli/#using-efficacy-cli","text":"The Efficacy compiler and interactive environment can be called from the terminal by running efficacy .","title":"Using Efficacy CLI"},{"location":"efficacy/01-cli/#arguments","text":"The following are arguments that can be passed to Efficacy to specify details. Running Efficacy without any arguments opens the interactive mode. Argument Full Argument Required Description -i --input No 1 The path to the input file to compile -o --output No The path to where the compiled executable will be placed -oT --output-tokens No The path to where the token file will be placed -oA --output-abstract-tree No The path to where the abstract tree file will be placed","title":"Arguments"},{"location":"efficacy/01-cli/#creating-a-token-file","text":"Efficacy supports creating a JSON file containing the tokens it discovered while tokenizing the input file. It mainly contains a list of objects with the token type (see Lexical Elements ) and the token itself. This token file is useful when comparing a lexer's ability to tokenize an OcellusScript file to Efficacy's lexer, OSTokenizer . Example [ { Identifier : x }, { Symbol : = }, { Identifier : x }, { Symbol : + }, { IntConstant : 5 }, ]","title":"Creating a Token File"},{"location":"efficacy/01-cli/#creating-an-abstract-syntax-tree-file","text":"Efficacy also supports creating a JSON file that represents the parsed abstract syntax tree from the input file. This contains a tree structure as described in the language specification , which may be useful for comparing a custom parser with Efficacy's OSParser . Example { module : { name : Example , importable : true , depends : [ Hive.* ], types : [], datatypes : [], functions : [ { function : { name : test , signature : {}, docstring : , body : [ { params : [], result : { expression : { ... } } } ] } } ] } } The input argument is required when compiling files or preparing a tokenized or parsed JSON file.","title":"Creating an Abstract Syntax Tree File"},{"location":"efficacy/module/","text":"The Efficacy Module Efficacy can be used in Python scripts and projects as an importable module. The following documentation covers all of the publicly-facing APIs and utilities available in the Efficacy package. Table of Contents CLI Lexer Parser","title":"The Efficacy Module"},{"location":"efficacy/module/#the-efficacy-module","text":"Efficacy can be used in Python scripts and projects as an importable module. The following documentation covers all of the publicly-facing APIs and utilities available in the Efficacy package.","title":"The Efficacy Module"},{"location":"efficacy/module/#table-of-contents","text":"CLI Lexer Parser","title":"Table of Contents"},{"location":"efficacy/module/00-cli/","text":"CLI The cli submodule of Efficacy contains the source code and functionality for the command-line application version of the Efficacy compiler. run_cli Start the main process for the CLI application. Arguments with_args : (Optional) The arguments to run the CLI with (see Using Efficacy CLI ). Will default to sys.argv if no arguments have been supplied. Example Below is an example of how the CLI can be called programmatically using run_cli() . from efficacy.cli import run_cli from subproccess import check_call print ( check_call ( run_cli ([ -i , main.ocls , -oT , tokens.json ])))","title":"CLI"},{"location":"efficacy/module/00-cli/#cli","text":"The cli submodule of Efficacy contains the source code and functionality for the command-line application version of the Efficacy compiler.","title":"CLI"},{"location":"efficacy/module/00-cli/#run_cli","text":"Start the main process for the CLI application. Arguments with_args : (Optional) The arguments to run the CLI with (see Using Efficacy CLI ). Will default to sys.argv if no arguments have been supplied. Example Below is an example of how the CLI can be called programmatically using run_cli() . from efficacy.cli import run_cli from subproccess import check_call print ( check_call ( run_cli ([ -i , main.ocls , -oT , tokens.json ])))","title":"run_cli"},{"location":"efficacy/module/01-lexer/","text":"Lexer The lexer submodule of Efficacy contains all of the tools necessary to tokenize a string or a file into a a list of OcellusScript tokens. OSTokenType An enumeration type for the different token types. This enumeration class is used to differentiate between the different types of tokens used for OcellusScript parsing. The values of the enumerations correspond to the lexical grammar names for each type. Key Corresponding Value keyword Keyword identifier Identifier string StringConstant docstring DocstringConstant comment CommentConstant symbol Symbol num_integer IntConstant num_float FloatConstant operator Operator newline LineReturn OSTokenizer The tokenizing class for OcellusScript. The tokenizer is responsible for converting a stream of characters into OcellusScript tokens that can be used for parsing. Example Below is an example of how OSTokenizer can be used to create a list of tokens from a string containing OcellusScript code. from efficacy.lexer import OSTokenizer lexer = OSTokenizer ( script = example x = x 5 ? x + 6 : x + 8 \\n ) tokens = lexer . tokenize () print ( tokens [ 0 ]) # ( OSTokenType: OSTokenType.identifier , example ) Attributes source : The list of characters that will be converted to tokens Methods __init__ Initialize the tokenizer. Arguments script : The script string to tokenize tokenize Generate a list of tokens from a given string. Returns : A list containing the tokens as a tuple containing the token's type and the token itself.","title":"Lexer"},{"location":"efficacy/module/01-lexer/#lexer","text":"The lexer submodule of Efficacy contains all of the tools necessary to tokenize a string or a file into a a list of OcellusScript tokens.","title":"Lexer"},{"location":"efficacy/module/01-lexer/#ostokentype","text":"An enumeration type for the different token types. This enumeration class is used to differentiate between the different types of tokens used for OcellusScript parsing. The values of the enumerations correspond to the lexical grammar names for each type. Key Corresponding Value keyword Keyword identifier Identifier string StringConstant docstring DocstringConstant comment CommentConstant symbol Symbol num_integer IntConstant num_float FloatConstant operator Operator newline LineReturn","title":"OSTokenType"},{"location":"efficacy/module/01-lexer/#ostokenizer","text":"The tokenizing class for OcellusScript. The tokenizer is responsible for converting a stream of characters into OcellusScript tokens that can be used for parsing. Example Below is an example of how OSTokenizer can be used to create a list of tokens from a string containing OcellusScript code. from efficacy.lexer import OSTokenizer lexer = OSTokenizer ( script = example x = x 5 ? x + 6 : x + 8 \\n ) tokens = lexer . tokenize () print ( tokens [ 0 ]) # ( OSTokenType: OSTokenType.identifier , example )","title":"OSTokenizer"},{"location":"efficacy/module/01-lexer/#attributes","text":"source : The list of characters that will be converted to tokens","title":"Attributes"},{"location":"efficacy/module/01-lexer/#methods","text":"","title":"Methods"},{"location":"efficacy/module/01-lexer/#__init__","text":"Initialize the tokenizer. Arguments script : The script string to tokenize","title":"__init__"},{"location":"efficacy/module/01-lexer/#tokenize","text":"Generate a list of tokens from a given string. Returns : A list containing the tokens as a tuple containing the token's type and the token itself.","title":"tokenize"},{"location":"efficacy/module/02-parser/","text":"Parser The parser submodule of Efficacy contains all of the tools necessary to parse a list of tokens into an abstract syntax tree to be used for compilation or additional processing. OSParserError The base error to use when the parser has failed. OSParser The parsing class for OcellusScript. The parser is responsible for reading a list of tokens and converting the them into a traversable abstract syntax tree that can be used to compile into a program with LLVM or can be processed differently with a Python script. Example The following is an example of how the parser can be used to create the abstract syntax tree. from efficacy.parser import OSParser example_src = module Example where example takes Nothing returns Integer example = 5 parsed = OSParser ( script = example_src ) . parse () print ( parsed ) Methods __init__ Initialize the OcellusScript Parser object. Keyword Arguments script : The string containing the code to parse. The parser will tokenize this script before parsing it. tokens : The pre-processed list of tokens to use for parsing. parse Parse the list of tokens and return an abstract syntax tree. Returns : A JSON-like dictionary containing all of the parsed functions, expression, and modules. Raises : OSParserError if there's an error in the syntax of the current token being processed.","title":"Parser"},{"location":"efficacy/module/02-parser/#parser","text":"The parser submodule of Efficacy contains all of the tools necessary to parse a list of tokens into an abstract syntax tree to be used for compilation or additional processing.","title":"Parser"},{"location":"efficacy/module/02-parser/#osparsererror","text":"The base error to use when the parser has failed.","title":"OSParserError"},{"location":"efficacy/module/02-parser/#osparser","text":"The parsing class for OcellusScript. The parser is responsible for reading a list of tokens and converting the them into a traversable abstract syntax tree that can be used to compile into a program with LLVM or can be processed differently with a Python script. Example The following is an example of how the parser can be used to create the abstract syntax tree. from efficacy.parser import OSParser example_src = module Example where example takes Nothing returns Integer example = 5 parsed = OSParser ( script = example_src ) . parse () print ( parsed )","title":"OSParser"},{"location":"efficacy/module/02-parser/#methods","text":"","title":"Methods"},{"location":"efficacy/module/02-parser/#__init__","text":"Initialize the OcellusScript Parser object. Keyword Arguments script : The string containing the code to parse. The parser will tokenize this script before parsing it. tokens : The pre-processed list of tokens to use for parsing.","title":"__init__"},{"location":"efficacy/module/02-parser/#parse","text":"Parse the list of tokens and return an abstract syntax tree. Returns : A JSON-like dictionary containing all of the parsed functions, expression, and modules. Raises : OSParserError if there's an error in the syntax of the current token being processed.","title":"parse"},{"location":"language/","text":"Welcome to OcellusScript The following documentation will guide you through learning the general syntax and nature of OcellusScript. What is OcellusScript? OcellusScript is a functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel. OcellusScript heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language. Table of Contents Expressions and Basic Types Defining Functions (Callables) Conditionals Lists and Pattern Matching Custom Types and Optionals Recursion Higher-order Functions and Lambda Expressions Error Handling Modules and Main Execution Stylebook Specification The Hive Module","title":"Welcome <small>to OcellusScript</small>"},{"location":"language/#welcome-to-ocellusscript","text":"The following documentation will guide you through learning the general syntax and nature of OcellusScript.","title":"Welcome to OcellusScript"},{"location":"language/#what-is-ocellusscript","text":"OcellusScript is a functional programming language, originally designed to work hand-in-hand with the coding mini game from the Unscripted visual novel. OcellusScript heavily draws inspiration and syntax from languages like Haskell, Swift, JavaScript/ES5, and Python. OcellusScript aims to be an easy-to-use, type safe, and powerful language.","title":"What is OcellusScript?"},{"location":"language/#table-of-contents","text":"Expressions and Basic Types Defining Functions (Callables) Conditionals Lists and Pattern Matching Custom Types and Optionals Recursion Higher-order Functions and Lambda Expressions Error Handling Modules and Main Execution Stylebook Specification The Hive Module","title":"Table of Contents"},{"location":"language/01-expressions/","text":"Expressions and Basic Types OcellusScript works like most programming languages and contains basic types: Characters are an individual alphanumeric or Unicode character wrapped in single quotes (example: '\\n' ). Strings are usually a list of Characters wrapped in double quotes (example: \"Howdy\" ). Integers are whole numbers (example: 5 ). Floats are numbers that aren't exactly whole; rather, they may be a decimal or fraction (example: 3.141 ). Booleans are a binary type that usually is either true (1) or false (0). Likewise, there are other types in Ocellus: Callables are functions, expressions, or methods. Nothing is a void type to indicate a value of nothing. Usually comparable to null or nil in other languages. It is also the default type when no value is given in an optional type . Anything is also a void type, but is often used as a container type to describe any type. Error is a String-like type that disrupts program execution flow or requires special processing. Evaluating Expressions OcellusScript is a functional language and mostly works off of expression evaluation. When expressions are evaluated, they will return a type and its result. Take a look at the following examples: 1 * 2 returns an Integer with a result of 2 . \"cat\" + \"dog\" returns a String with a result of \"catdog\" . true or false returns a Boolean with a result of true . Operators The following operators can be used to evaluate an expression: + will add values. In the case of numbers, these will mathematically add up, while in the case of strings, these will concatenate the strings together. - will subtract values, usually only with numbers. * will multiply values, usually only with numbers. / will divide numbers. In the case of integers, these will try to divide it evenly and give the whole number with no remainder. For floats, this will return the whole number and its remainder. % will get the remainder of a division, usually use with integers. == will check if two values are equal to each other. Expression Precedence OcellusScript will handle certain expressions a little bit differently and follow a specific order of operations. The following is the order of precedence ind descending order (i.e., highest at the top). Basic expression types ( 8 ), expressions wrapped in parentheses ( (7 - 2) ), and/or lists ( [1, 2, 3] ) Multiplicative expressions such as multiplication ( g * 5 ), division ( g / 5 ), and remainder division (modulus) ( g % 5 ) Additive expressions such as addition ( m + 7 ) and subtraction ( m - 5 ) Basic inequality expressions such as greater-than ( h 5 ) and less-than ( h 5 ) Complex inequality expressions such as greater-than-or-equal-to ( m = 8 ) and less-than-or-equal-to ( h = 5 ) Equality expressions ( m == g or m != g ) Boolean expressions ( a and b , a or b , not a ) Conditional expressions ( a ? b : c ) Sometimes, OcellusScript may be unaware of when an expression is meant to be evaluated before an outer expression. Wrap your expression in parentheses to avoid this: example f = f 5 ? f : -1 # Syntax error example f = (f 5) ? f : -1 # OK","title":"Expressions and Basic Types"},{"location":"language/01-expressions/#expressions-and-basic-types","text":"OcellusScript works like most programming languages and contains basic types: Characters are an individual alphanumeric or Unicode character wrapped in single quotes (example: '\\n' ). Strings are usually a list of Characters wrapped in double quotes (example: \"Howdy\" ). Integers are whole numbers (example: 5 ). Floats are numbers that aren't exactly whole; rather, they may be a decimal or fraction (example: 3.141 ). Booleans are a binary type that usually is either true (1) or false (0). Likewise, there are other types in Ocellus: Callables are functions, expressions, or methods. Nothing is a void type to indicate a value of nothing. Usually comparable to null or nil in other languages. It is also the default type when no value is given in an optional type . Anything is also a void type, but is often used as a container type to describe any type. Error is a String-like type that disrupts program execution flow or requires special processing.","title":"Expressions and Basic Types"},{"location":"language/01-expressions/#evaluating-expressions","text":"OcellusScript is a functional language and mostly works off of expression evaluation. When expressions are evaluated, they will return a type and its result. Take a look at the following examples: 1 * 2 returns an Integer with a result of 2 . \"cat\" + \"dog\" returns a String with a result of \"catdog\" . true or false returns a Boolean with a result of true .","title":"Evaluating Expressions"},{"location":"language/01-expressions/#operators","text":"The following operators can be used to evaluate an expression: + will add values. In the case of numbers, these will mathematically add up, while in the case of strings, these will concatenate the strings together. - will subtract values, usually only with numbers. * will multiply values, usually only with numbers. / will divide numbers. In the case of integers, these will try to divide it evenly and give the whole number with no remainder. For floats, this will return the whole number and its remainder. % will get the remainder of a division, usually use with integers. == will check if two values are equal to each other.","title":"Operators"},{"location":"language/01-expressions/#expression-precedence","text":"OcellusScript will handle certain expressions a little bit differently and follow a specific order of operations. The following is the order of precedence ind descending order (i.e., highest at the top). Basic expression types ( 8 ), expressions wrapped in parentheses ( (7 - 2) ), and/or lists ( [1, 2, 3] ) Multiplicative expressions such as multiplication ( g * 5 ), division ( g / 5 ), and remainder division (modulus) ( g % 5 ) Additive expressions such as addition ( m + 7 ) and subtraction ( m - 5 ) Basic inequality expressions such as greater-than ( h 5 ) and less-than ( h 5 ) Complex inequality expressions such as greater-than-or-equal-to ( m = 8 ) and less-than-or-equal-to ( h = 5 ) Equality expressions ( m == g or m != g ) Boolean expressions ( a and b , a or b , not a ) Conditional expressions ( a ? b : c ) Sometimes, OcellusScript may be unaware of when an expression is meant to be evaluated before an outer expression. Wrap your expression in parentheses to avoid this: example f = f 5 ? f : -1 # Syntax error example f = (f 5) ? f : -1 # OK","title":"Expression Precedence"},{"location":"language/02-functions/","text":"Defining Functions (Callables) The bulk of OcellusScript's language works around defining functions, which evaluate expressions when called. For example, let's write a function that evaluates the square of a given integer. This can be done by writing the following: square number = number * number Where the following apply on the left side of the equal sign: square is the name of the function. To call this function at any time, we simply refer to square . number is the name of the argument that gets passed into the expression. On the right side of the equal sign is the evaluation of the expression where we multiply the number we pass in by itself. Since the evaluation returns a number, the result of this evaluation will be the result of this function. So, now, it's possible to call upon the square function and use its result elsewhere. For example: square 4 Functions can also call upon other functions to make more complex results. For instance, the following function uses square in its evaluation: evenSquare number = (square number) % 2 == 0 First, OcellusScript will evaluate the square function and then use its result to calculate whether or not dividing it by 2 will give a remainder. OcellusScript will evaluate functions wrapped in parentheses ( () ) and work outward to the top level. Functions can also have more than one parameter. For instance, if we wanted to write a function that determines whether or not two numbers are two away from each other, we can do the following: offByTwo x y = y - x == 2 Where we now have two parameters, x and y . Order of parameters usually matters and will affect how the function is evaluated. Likewise, the offByTwo function can now be called as the following: offByTwo 3 5 Function are Not Variables It is important to keep in mind that writing functions in OcellusScript does not mean that they are variables. Any function definition is a Callable that usually returns a value. For instance, the following might look like a variable assignment in Python: helloWorld = Hello, world! When, in fact, this is not a variable. This is a parameterless function that returns the evaluation of the string \"Hello, world!\" . Type Signatures Type signatures are additional pieces of text above function definitions that help describe its parameters and its return type. This is used to describe the function and force type checking since OcellusScript doesn't require types to be declared immediately. For instance, let's refer to helloWorld again: helloWorld takes Nothing returns String helloWorld = Hello, world! We can now clearly see that this function is indeed a function and that it has no parameters at all. Typically, type signatures will have the following pattern: First, the function name is written to denote that the signature applies to that function. In this case, the function's name is helloWorld . takes defines the parameters and its associated types. In this case, there are no parameters, so it takes a Nothing type. returns defines the type that gets returned. In this case, the String type is returned. Likewise, this can be applies to multi-parameter functions. Take a look at the type signature for offByTwo : offByTwo takes Integer and Integer returns Boolean offByTwo x y = y - x == 2 We can now see the following: offByTwo will only work with integers as their parameters. The and indicates the second parameter. offByTwo returns a boolean value instead of a number. Callables as Parameters in a Type Signature There may be cases where a function itself is passed into another function as a parameter, like in higher-order functions . To accomodate for this, the type signature can be modified to indicate that it takes a function ( Callable ) with its own parameters and return type. Take a look at the example below: test takes (Callable takes Integer returns Integer) \\ and Integer returns Integer","title":"Defining Functions (Callables)"},{"location":"language/02-functions/#defining-functions-callables","text":"The bulk of OcellusScript's language works around defining functions, which evaluate expressions when called. For example, let's write a function that evaluates the square of a given integer. This can be done by writing the following: square number = number * number Where the following apply on the left side of the equal sign: square is the name of the function. To call this function at any time, we simply refer to square . number is the name of the argument that gets passed into the expression. On the right side of the equal sign is the evaluation of the expression where we multiply the number we pass in by itself. Since the evaluation returns a number, the result of this evaluation will be the result of this function. So, now, it's possible to call upon the square function and use its result elsewhere. For example: square 4 Functions can also call upon other functions to make more complex results. For instance, the following function uses square in its evaluation: evenSquare number = (square number) % 2 == 0 First, OcellusScript will evaluate the square function and then use its result to calculate whether or not dividing it by 2 will give a remainder. OcellusScript will evaluate functions wrapped in parentheses ( () ) and work outward to the top level. Functions can also have more than one parameter. For instance, if we wanted to write a function that determines whether or not two numbers are two away from each other, we can do the following: offByTwo x y = y - x == 2 Where we now have two parameters, x and y . Order of parameters usually matters and will affect how the function is evaluated. Likewise, the offByTwo function can now be called as the following: offByTwo 3 5 Function are Not Variables It is important to keep in mind that writing functions in OcellusScript does not mean that they are variables. Any function definition is a Callable that usually returns a value. For instance, the following might look like a variable assignment in Python: helloWorld = Hello, world! When, in fact, this is not a variable. This is a parameterless function that returns the evaluation of the string \"Hello, world!\" .","title":"Defining Functions (Callables)"},{"location":"language/02-functions/#type-signatures","text":"Type signatures are additional pieces of text above function definitions that help describe its parameters and its return type. This is used to describe the function and force type checking since OcellusScript doesn't require types to be declared immediately. For instance, let's refer to helloWorld again: helloWorld takes Nothing returns String helloWorld = Hello, world! We can now clearly see that this function is indeed a function and that it has no parameters at all. Typically, type signatures will have the following pattern: First, the function name is written to denote that the signature applies to that function. In this case, the function's name is helloWorld . takes defines the parameters and its associated types. In this case, there are no parameters, so it takes a Nothing type. returns defines the type that gets returned. In this case, the String type is returned. Likewise, this can be applies to multi-parameter functions. Take a look at the type signature for offByTwo : offByTwo takes Integer and Integer returns Boolean offByTwo x y = y - x == 2 We can now see the following: offByTwo will only work with integers as their parameters. The and indicates the second parameter. offByTwo returns a boolean value instead of a number.","title":"Type Signatures"},{"location":"language/02-functions/#callables-as-parameters-in-a-type-signature","text":"There may be cases where a function itself is passed into another function as a parameter, like in higher-order functions . To accomodate for this, the type signature can be modified to indicate that it takes a function ( Callable ) with its own parameters and return type. Take a look at the example below: test takes (Callable takes Integer returns Integer) \\ and Integer returns Integer","title":"Callables as Parameters in a Type Signature"},{"location":"language/03-conditionals/","text":"Conditionals Often, you'll need to compare two values to each other and use its comparison. These conditional operators can be used in expression evaluation: == will determine whether two values are equal to each other. != will determine whether two values are not equal to each other. will determine whether the first value is less than the second value. will determine whether the first value is greater than the second value. = will determine whether the first value is less than or equal to the second value. = will determine whether the first value is greater than or equal to the second value. It's important to note that comparisons are usually type inclusive, meaning that the types are also compared. \"2\" == 2 will always evaluate to false since the types are different, but 2 == 2 will always evaluate to true because the types are the same. Comparisons will always return a boolean value. Boolean operators Comparisons and conditions can work with each other using boolean operators: and determines whether both the first value and the second value will evaluate to true . not will take the opposite conditional value (i.e. true to false ). or determines whether either the first value or the second value will evaluate to true . Working with Conditionals The ternary operator syntax is used to determine what to further evaluate or return based on a condition. The typical syntax is as follows: (condition) ? (expression to evaluate if condition) : (expression to evaluate if not condition) The following is also valid syntax: condition ? true : false so, for example, the following will make a log entry depending on what gets passed into the function warnForVillain : warnForVillain name = (isVillain name) ? (warn Careful! + villain + is a villain. ) : (log You re safe. )","title":"Conditionals"},{"location":"language/03-conditionals/#conditionals","text":"Often, you'll need to compare two values to each other and use its comparison. These conditional operators can be used in expression evaluation: == will determine whether two values are equal to each other. != will determine whether two values are not equal to each other. will determine whether the first value is less than the second value. will determine whether the first value is greater than the second value. = will determine whether the first value is less than or equal to the second value. = will determine whether the first value is greater than or equal to the second value. It's important to note that comparisons are usually type inclusive, meaning that the types are also compared. \"2\" == 2 will always evaluate to false since the types are different, but 2 == 2 will always evaluate to true because the types are the same. Comparisons will always return a boolean value.","title":"Conditionals"},{"location":"language/03-conditionals/#boolean-operators","text":"Comparisons and conditions can work with each other using boolean operators: and determines whether both the first value and the second value will evaluate to true . not will take the opposite conditional value (i.e. true to false ). or determines whether either the first value or the second value will evaluate to true .","title":"Boolean operators"},{"location":"language/03-conditionals/#working-with-conditionals","text":"The ternary operator syntax is used to determine what to further evaluate or return based on a condition. The typical syntax is as follows: (condition) ? (expression to evaluate if condition) : (expression to evaluate if not condition) The following is also valid syntax: condition ? true : false so, for example, the following will make a log entry depending on what gets passed into the function warnForVillain : warnForVillain name = (isVillain name) ? (warn Careful! + villain + is a villain. ) : (log You re safe. )","title":"Working with Conditionals"},{"location":"language/04-lists/","text":"Lists and Pattern Matching Another common type is a list. A list is a collection of items that can be iterated through. In Ocellus, lists works more like Haskell's list in the sense that they are nested pairs with a head and tail. For instance, take a look at the following list below: [1, 2, 3, 4] The following list in OcellusScript corresponds to the following: 1 : (2 : (3 : (4 : Nothing))) Lists in OcellusScript always have a Nothing type as the inner-most tail, though the list can be of any type inside with any length. Accessing a list is relatively straightforward using this syntax: (first : second : rest) Where first corresponds to the first item in the list, second refers to the second item, and rest refers to everything else after the first two elements. This syntax can be trimmed to refer to just the first item and the rest of the items, which may be useful in recursive cases: (head : tail) Where head refers to the first item and tail refers to everything after the fist item. Additionally, referring to an item in a list without referencing pairs is relatively easy to do with the standard list[index] syntax where index is the position of the element in the list. Lists in OcellusScript start at position 0 . List Utilities OcellusScript comes with some utility functions that work with lists to make things a bit easier. These utility functions accept a list of type [Anything] and return different values depending on the utility in question: length list will return an Integer that represents how many items are in a list. member item list will return a Boolean that indicates whether item is an element in list . map func list will return a list of [Anything] with the function func applied to it. filter func list will return a list of [Anything] based on if the items meet the condition defined in func . reduce func list startingValue will return a single value of type Anything based on a function func and staring with value startingValue . The functions map , filter , and reduce are discussed in great detail in the Higher-order Functions section, as well as the Hive module documentation . Lists can also be added/concatenated using the standard + operator, and - will remove the first instance of an element: addList takes Nothing returns [Integer] addList = [1, 2] + [3] # returns [1, 2, 3] removeList takes Nothing returns [Integer] removeList = [1, 2, 3, 2] - [2] # returns [1, 3, 2] Pattern Matching Likewise, functions in OcellusScript can also cover multiple cases based on a common pattern in the input parameters. Each definition will attempt to match a specific type of pattern, so it's recommended that functions define all types of patterns that are necessary. For instance, the butFirst function below will account for empty lists, lists with one item, and lists with multiple items: butFirst takes [Anything] returns [Anything] butFirst [] = [] butFirst [x] = [x] butFirst (head:tail) = tail Note that there are three definitions listed: butFirst [] will match for empty lists specifically butFirst [x] will match for lists that contain only one item butFirst (head:tail) will match for lists that contain a head and a tail. Pattern matching works in OcellusScript regardless of the input type. For instance, take a look at the following function isEven which determines whether an optional integer is even or not: isEven takes Integer? returns Boolean isEven Nothing = false isEven number = number % 2 == 0 It is important to note that OcellusScript will match patters in the order that they are defined in. In the case of isEven , the function will attempt to match the pattern isEven Nothing before matching the pattern isEven number . OcellusScript patterns can ignore certain information by replacing it with an underscore, like below: butFirst (_ : tail) = tail Where OcellusScript will ignore the head of the list pair.","title":"Lists and Pattern Matching"},{"location":"language/04-lists/#lists-and-pattern-matching","text":"Another common type is a list. A list is a collection of items that can be iterated through. In Ocellus, lists works more like Haskell's list in the sense that they are nested pairs with a head and tail. For instance, take a look at the following list below: [1, 2, 3, 4] The following list in OcellusScript corresponds to the following: 1 : (2 : (3 : (4 : Nothing))) Lists in OcellusScript always have a Nothing type as the inner-most tail, though the list can be of any type inside with any length. Accessing a list is relatively straightforward using this syntax: (first : second : rest) Where first corresponds to the first item in the list, second refers to the second item, and rest refers to everything else after the first two elements. This syntax can be trimmed to refer to just the first item and the rest of the items, which may be useful in recursive cases: (head : tail) Where head refers to the first item and tail refers to everything after the fist item. Additionally, referring to an item in a list without referencing pairs is relatively easy to do with the standard list[index] syntax where index is the position of the element in the list. Lists in OcellusScript start at position 0 .","title":"Lists and Pattern Matching"},{"location":"language/04-lists/#list-utilities","text":"OcellusScript comes with some utility functions that work with lists to make things a bit easier. These utility functions accept a list of type [Anything] and return different values depending on the utility in question: length list will return an Integer that represents how many items are in a list. member item list will return a Boolean that indicates whether item is an element in list . map func list will return a list of [Anything] with the function func applied to it. filter func list will return a list of [Anything] based on if the items meet the condition defined in func . reduce func list startingValue will return a single value of type Anything based on a function func and staring with value startingValue . The functions map , filter , and reduce are discussed in great detail in the Higher-order Functions section, as well as the Hive module documentation . Lists can also be added/concatenated using the standard + operator, and - will remove the first instance of an element: addList takes Nothing returns [Integer] addList = [1, 2] + [3] # returns [1, 2, 3] removeList takes Nothing returns [Integer] removeList = [1, 2, 3, 2] - [2] # returns [1, 3, 2]","title":"List Utilities"},{"location":"language/04-lists/#pattern-matching","text":"Likewise, functions in OcellusScript can also cover multiple cases based on a common pattern in the input parameters. Each definition will attempt to match a specific type of pattern, so it's recommended that functions define all types of patterns that are necessary. For instance, the butFirst function below will account for empty lists, lists with one item, and lists with multiple items: butFirst takes [Anything] returns [Anything] butFirst [] = [] butFirst [x] = [x] butFirst (head:tail) = tail Note that there are three definitions listed: butFirst [] will match for empty lists specifically butFirst [x] will match for lists that contain only one item butFirst (head:tail) will match for lists that contain a head and a tail. Pattern matching works in OcellusScript regardless of the input type. For instance, take a look at the following function isEven which determines whether an optional integer is even or not: isEven takes Integer? returns Boolean isEven Nothing = false isEven number = number % 2 == 0 It is important to note that OcellusScript will match patters in the order that they are defined in. In the case of isEven , the function will attempt to match the pattern isEven Nothing before matching the pattern isEven number . OcellusScript patterns can ignore certain information by replacing it with an underscore, like below: butFirst (_ : tail) = tail Where OcellusScript will ignore the head of the list pair.","title":"Pattern Matching"},{"location":"language/05-types/","text":"Custom Types and Optionals OcellusScript supports writing custom data types and types that inherit basic types. This can often be used to represent trees or a specific type of data. The type function can be used to define a new type that is inherited from any of the basic types : type Side = Float type Radius = Float Where Side and Radius is a type that is inherited from the Float type. Likewise, defining custom data types is accomplished with the datatype function: datatype Shape = Rectangle Side Side or Ellipse Radius Radius Where Shape can now either be a data type of Rectangle with parameters Side and Side or a data type of Ellipse with parameters Radius and Radius . Naming Types Custom types and datatype structures must always be named in Pascal case ( PascalCase ) to avoid confusion with other functions and keywords. OcellusScript will work with custom types and data types as standard types in functions, which is useful in pattern matching cases. The following area function matches across different type patterns to calculate a shape's area: area takes Shape returns Float area (Rectangle x y) = x * y area (Ellipse r q) = pi * r * q Data types are often useful for creating custom types with specific attributes or for creating tree-like structures. For instance, the following code includes a custom tree data type and a function to collapse a tree into a single value with pattern matching: datatype NumberTree = Leaf Integer or Branch Integer NumberTree NumberTree collapseTree takes NumberTree returns Integer collapseTree (Leaf n) = n collapseTree (Branch n x y) n + (collapseTree x) + (collapseTree y) sampleTree = Branch 0 (Leaf 6) (Branch 1 (Leaf 2) (Leaf 9)) collapsedSample = collapseTree sampleTree Note that in the pattern collapseTree (Branch n x y) , the function calls upon itself to collapse the subtrees x and y . OcellusScript support different types of recursion and allows for this kind of behavior. Optional Types OcellusScript also support types that may contain a specific type of value or Nothing . These types, known as optionals , are often used in cases where the type of data being returned is unclear. Optional types are denoted by ? at the end of the type. For instance, the following function getDefaultHealth will return an integer or a default value if Nothing is received. getDefaultHealth takes Integer? returns Integer getDefaultHealth health = health ?? 100 The ?? operator in the expression indicates that the following value should be used if the preceding value is of type Nothing . Similarly, this function can be rewritten using pattern matching to make this clearer: getDefaultHealth takes Integer? returns Integer getDefaultHealth Nothing = 100 getDefaultHealth health = health Currently, functions that use optional types must account for when a type returns Nothing instead of the intended value and does not support force unwrapping. However, this behavior can be replicated (if desired) with a sample utility function like the one below: datatype ForcedValue = Anything or Error forceUnwrap takes Anything? returns ForcedValue forceUnrwap value = value ?? Error Cannot unwrap value Nothing.","title":"Custom Types and Optionals"},{"location":"language/05-types/#custom-types-and-optionals","text":"OcellusScript supports writing custom data types and types that inherit basic types. This can often be used to represent trees or a specific type of data. The type function can be used to define a new type that is inherited from any of the basic types : type Side = Float type Radius = Float Where Side and Radius is a type that is inherited from the Float type. Likewise, defining custom data types is accomplished with the datatype function: datatype Shape = Rectangle Side Side or Ellipse Radius Radius Where Shape can now either be a data type of Rectangle with parameters Side and Side or a data type of Ellipse with parameters Radius and Radius . Naming Types Custom types and datatype structures must always be named in Pascal case ( PascalCase ) to avoid confusion with other functions and keywords. OcellusScript will work with custom types and data types as standard types in functions, which is useful in pattern matching cases. The following area function matches across different type patterns to calculate a shape's area: area takes Shape returns Float area (Rectangle x y) = x * y area (Ellipse r q) = pi * r * q Data types are often useful for creating custom types with specific attributes or for creating tree-like structures. For instance, the following code includes a custom tree data type and a function to collapse a tree into a single value with pattern matching: datatype NumberTree = Leaf Integer or Branch Integer NumberTree NumberTree collapseTree takes NumberTree returns Integer collapseTree (Leaf n) = n collapseTree (Branch n x y) n + (collapseTree x) + (collapseTree y) sampleTree = Branch 0 (Leaf 6) (Branch 1 (Leaf 2) (Leaf 9)) collapsedSample = collapseTree sampleTree Note that in the pattern collapseTree (Branch n x y) , the function calls upon itself to collapse the subtrees x and y . OcellusScript support different types of recursion and allows for this kind of behavior.","title":"Custom Types and Optionals"},{"location":"language/05-types/#optional-types","text":"OcellusScript also support types that may contain a specific type of value or Nothing . These types, known as optionals , are often used in cases where the type of data being returned is unclear. Optional types are denoted by ? at the end of the type. For instance, the following function getDefaultHealth will return an integer or a default value if Nothing is received. getDefaultHealth takes Integer? returns Integer getDefaultHealth health = health ?? 100 The ?? operator in the expression indicates that the following value should be used if the preceding value is of type Nothing . Similarly, this function can be rewritten using pattern matching to make this clearer: getDefaultHealth takes Integer? returns Integer getDefaultHealth Nothing = 100 getDefaultHealth health = health Currently, functions that use optional types must account for when a type returns Nothing instead of the intended value and does not support force unwrapping. However, this behavior can be replicated (if desired) with a sample utility function like the one below: datatype ForcedValue = Anything or Error forceUnwrap takes Anything? returns ForcedValue forceUnrwap value = value ?? Error Cannot unwrap value Nothing.","title":"Optional Types"},{"location":"language/06-recursion/","text":"Recursion OcellusScript supports different types of recursion and are relatively easy to implement. The most typical form of recursion used in OcellusScript is linear recursion and works by processing a single element and constantly working on elements until the innermost element returns a single value. Elements then work upwards to \"collapse\" the work into a single evaluation. For instance, the following function below will keep working until the element value in question is divisible by 2: myEquation takes Integer returns Integer myEquation n = n % 2 == 0 ? n + 5 : myEquation (n * 2) The following would be how OcellusScript processes myEquation with the input parameter being 5 : Start with myEquation n where n = 5. Check if n is divisible by 2. n is NOT divisible by 2, so we multiply n by 2. New n = 10. Evaluate myEquation where n = 10. Check if n is divisible by 2. n IS divisible by 2, so we evaluate n + 5. n + 5 is 15. Return back value 15. Evaluation returns 15. Evaluation returns 15. where Expression Sometimes, it might be impractical to work with recursion and pattern matching all in a single function. To mitigate this, a helper function can be defined with the where expression. The following function reverse uses the where expression to write a pattern matching function that then can get used recursively. reverse takes String returns String reverse word = reverseHelper word where reverseHelper [] newWord = newWord reverseHelper character newWord = newWord + [character] reverseHelper (firstChar : otherChars) = reverseHelper otherChars (newWord + [firstChar]) The helper function reverseHelper gets called recursively when dealing with strings of more than one character in length and will transfer the letters over to newWord . After evaluating reverseHelper , the return value is returned to the original function. The where expression can be used to define a function preceding it or a specific value and is often used in cases of tail recursion or when pattern matching is needed. Note that the type signature for reverse does not include the signature for reverseHelper as it is not required.","title":"Recursion"},{"location":"language/06-recursion/#recursion","text":"OcellusScript supports different types of recursion and are relatively easy to implement. The most typical form of recursion used in OcellusScript is linear recursion and works by processing a single element and constantly working on elements until the innermost element returns a single value. Elements then work upwards to \"collapse\" the work into a single evaluation. For instance, the following function below will keep working until the element value in question is divisible by 2: myEquation takes Integer returns Integer myEquation n = n % 2 == 0 ? n + 5 : myEquation (n * 2) The following would be how OcellusScript processes myEquation with the input parameter being 5 : Start with myEquation n where n = 5. Check if n is divisible by 2. n is NOT divisible by 2, so we multiply n by 2. New n = 10. Evaluate myEquation where n = 10. Check if n is divisible by 2. n IS divisible by 2, so we evaluate n + 5. n + 5 is 15. Return back value 15. Evaluation returns 15. Evaluation returns 15.","title":"Recursion"},{"location":"language/06-recursion/#where-expression","text":"Sometimes, it might be impractical to work with recursion and pattern matching all in a single function. To mitigate this, a helper function can be defined with the where expression. The following function reverse uses the where expression to write a pattern matching function that then can get used recursively. reverse takes String returns String reverse word = reverseHelper word where reverseHelper [] newWord = newWord reverseHelper character newWord = newWord + [character] reverseHelper (firstChar : otherChars) = reverseHelper otherChars (newWord + [firstChar]) The helper function reverseHelper gets called recursively when dealing with strings of more than one character in length and will transfer the letters over to newWord . After evaluating reverseHelper , the return value is returned to the original function. The where expression can be used to define a function preceding it or a specific value and is often used in cases of tail recursion or when pattern matching is needed. Note that the type signature for reverse does not include the signature for reverseHelper as it is not required.","title":"where Expression"},{"location":"language/07-hoc/","text":"Higher-order Functions and Lambdas OcellusScript supports writing functions that will accept functions as parameters. These functions, called higher-order functions, will usually take a function as one of its inputs or return a function as its output. OcellusScript comes with some higher-order functions for use with iteration and lists that are built into the Hive module , the standard library module for OcellusScript. for The for function takes three inputs: a starting value, and ending value, and a callable function to run. The callable function can be written by any means and supports the where expression. An example of the for function is provided with the countToTen example where a number is logged through each iteration. import Hive only for countToTen takes Nothing returns Nothing countToTen = for 0 10 task where task i = log i It important to note that the for function will automatically take care of increasing the start value and decreasing the end value. More information on the for function can be found in the Hive module documentation . map The map function is a utility function that returns a list with a function applied to its elements. It accepts two parameters: the callable function to run on each element, and the list of items to run the callable function on. The following mapIfTwo function makes use of map to change a list of numbers into a list of booleans based on their divisibility: import Hive only map divisibleByTwo takes Integer returns Boolean divisibleByTwo num = num % 2 == 0 mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map divisibleByTwo list Note that the divisibleByTwo function does not get called in the mapIfTwo definition as map will automatically handle this. Below is the implementation for map : More information on the map function can be found in the Hive module documentation . filter The filter function is a utility function that returns a list of items that obey a following condition. It accepts two parameters: the callable function that determines whether an item will be in the new list, and the list to filter. The following containsBan function makes use of filter to filter out any words in the list that do not contain the letters b, a, or n: import Hive only filter, member banHelper takes String returns Boolean banHelper [] = true banHelper x = member x ban banHelper (x : xs) = (member x ban ) and (banHelper xs) containsBan takes [String] returns [String] containsBan list = filter banHelper list Again, note that banHelper does not get called in containsBan as filter handles this automatically. More information on the filter function can be found in the Hive module documentation . reduce The reduce function is a utility function that returns a single value of type Anything based on a method of reduction. It accepts three parameters: the callable function that dictates how values will be combined, the list to combine into a single value, and the starting value. The starting value will dictate what type the reduce function returns. The following smartAdd functions makes uses of reduce to add according to a specific set of rules: import Hive only reduce smartAdditionHelper takes Integer and Integer returns Integer smartAdditionHelper x y = y % 3 == 0 ? x + (y * 4) : x + y smartAdd takes [Integer] returns Integer smartAdd list = reduce smartAdditionHelper list 0 Again, note that smartAdditionHelper is not called inside of the smartAdd function as reduce calls this automatically when running. More information on the reduce function can be found in the Hive module documentation . Lambda Functions Sometimes it doesn't make sense to write a separate function to pass into a higher-order function like map . The lambda function is an in-line function that returns a function that evaluates a single expression from a select amount of parameters. The following example reduces the amount of code in mapIfTwo to use a lambda: mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map (lambda x - x % 2 == 0) list This can also be used in cases like the for function: countToFive takes Nothing returns Nothing countToFive = for 0 5 (lambda x - log x)","title":"Higher-order Functions and Lambdas"},{"location":"language/07-hoc/#higher-order-functions-and-lambdas","text":"OcellusScript supports writing functions that will accept functions as parameters. These functions, called higher-order functions, will usually take a function as one of its inputs or return a function as its output. OcellusScript comes with some higher-order functions for use with iteration and lists that are built into the Hive module , the standard library module for OcellusScript.","title":"Higher-order Functions and Lambdas"},{"location":"language/07-hoc/#for","text":"The for function takes three inputs: a starting value, and ending value, and a callable function to run. The callable function can be written by any means and supports the where expression. An example of the for function is provided with the countToTen example where a number is logged through each iteration. import Hive only for countToTen takes Nothing returns Nothing countToTen = for 0 10 task where task i = log i It important to note that the for function will automatically take care of increasing the start value and decreasing the end value. More information on the for function can be found in the Hive module documentation .","title":"for"},{"location":"language/07-hoc/#map","text":"The map function is a utility function that returns a list with a function applied to its elements. It accepts two parameters: the callable function to run on each element, and the list of items to run the callable function on. The following mapIfTwo function makes use of map to change a list of numbers into a list of booleans based on their divisibility: import Hive only map divisibleByTwo takes Integer returns Boolean divisibleByTwo num = num % 2 == 0 mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map divisibleByTwo list Note that the divisibleByTwo function does not get called in the mapIfTwo definition as map will automatically handle this. Below is the implementation for map : More information on the map function can be found in the Hive module documentation .","title":"map"},{"location":"language/07-hoc/#filter","text":"The filter function is a utility function that returns a list of items that obey a following condition. It accepts two parameters: the callable function that determines whether an item will be in the new list, and the list to filter. The following containsBan function makes use of filter to filter out any words in the list that do not contain the letters b, a, or n: import Hive only filter, member banHelper takes String returns Boolean banHelper [] = true banHelper x = member x ban banHelper (x : xs) = (member x ban ) and (banHelper xs) containsBan takes [String] returns [String] containsBan list = filter banHelper list Again, note that banHelper does not get called in containsBan as filter handles this automatically. More information on the filter function can be found in the Hive module documentation .","title":"filter"},{"location":"language/07-hoc/#reduce","text":"The reduce function is a utility function that returns a single value of type Anything based on a method of reduction. It accepts three parameters: the callable function that dictates how values will be combined, the list to combine into a single value, and the starting value. The starting value will dictate what type the reduce function returns. The following smartAdd functions makes uses of reduce to add according to a specific set of rules: import Hive only reduce smartAdditionHelper takes Integer and Integer returns Integer smartAdditionHelper x y = y % 3 == 0 ? x + (y * 4) : x + y smartAdd takes [Integer] returns Integer smartAdd list = reduce smartAdditionHelper list 0 Again, note that smartAdditionHelper is not called inside of the smartAdd function as reduce calls this automatically when running. More information on the reduce function can be found in the Hive module documentation .","title":"reduce"},{"location":"language/07-hoc/#lambda-functions","text":"Sometimes it doesn't make sense to write a separate function to pass into a higher-order function like map . The lambda function is an in-line function that returns a function that evaluates a single expression from a select amount of parameters. The following example reduces the amount of code in mapIfTwo to use a lambda: mapIfTwo takes [Integer] returns [Boolean] mapIfTwo list = map (lambda x - x % 2 == 0) list This can also be used in cases like the for function: countToFive takes Nothing returns Nothing countToFive = for 0 5 (lambda x - log x)","title":"Lambda Functions"},{"location":"language/08-error/","text":"Error Handling There may be functions that are defined in OcellusScript that might return an Error type and stop program flow. As a way to gracefully handle errors, the ternary-like ! operator syntax can be used. The following example code works with the forced unwrapped value code from the Optional Types section to handle error handling: addForcedValues takes ForcedValue returns Integer? addForcedValues x = (forceUnwrap x) ! x + 5 : log Couldn t unwrap value x","title":"Error Handling"},{"location":"language/08-error/#error-handling","text":"There may be functions that are defined in OcellusScript that might return an Error type and stop program flow. As a way to gracefully handle errors, the ternary-like ! operator syntax can be used. The following example code works with the forced unwrapped value code from the Optional Types section to handle error handling: addForcedValues takes ForcedValue returns Integer? addForcedValues x = (forceUnwrap x) ! x + 5 : log Couldn t unwrap value x","title":"Error Handling"},{"location":"language/09-modules/","text":"Modules and Main Execution OcellusScript works on a file-based level and supports creating and importing modules that contain other functions and utilities. When an OcellusScript file is written, it is considered a module in and of itself when the module function is defined. The following example in the file vill.ocls shows how a module is written: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] knownVillains = [(Villain Nightmare Moon true), (Villain Discord true), (Villain Tirek false), (Villain Tempest Shadow false), (Villain Starlight Glimmer false), (Villain Chrysalis false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) - reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains) vill.ocls is a typical OcellusScript file, but because the module function is defined at the top, all functions and types in this file are publicly accessible to other OcellusScript files by importing VillainDatabase . For example, another file called chr.ocls can make use of everything inside this module by using the import function: import VillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase Chrysalis Specific imports Importing the entire module may not be necessary and could cost performance. OcellusScript can handle this with specific imports. Again, with chr.ocls , we can manually import the inVillainDatabase function without importing everything else with the only statement: import VillainDatabase only inVillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase Chrysalis Likewise, except will import the entire module except a specific function: import VillainDatabase except knownByReform foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase Chrysalis Private functions Modules expose every function and type in a file and make it publicly accessible, which may not be desired. To mitigate this, adding the keyword private in front of a function definition will make sure that the function does not get imported when the module is imported. Looking back at vill.ocls , we could probably make the knownVillains function private so, say, a villain can't delete their entry from the database: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] private knownVillains = [(Villain Nightmare Moon true), (Villain Discord true), (Villain Tirek false), (Villain Tempest Shadow false), (Villain Starlight Glimmer false), (Villain Chrysalis false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) - reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains) Note that the private keyword does not need to be in the type signature of the function. Documentation Strings and Comments It's good practice to include documentation with your source code. Documentation often provides information on what a function will do or what a module contains. Documentation strings (docstrings) are denoted with a set of backticks (```) can be inserted between a type signature and a function definition like below: inVillainDatabase takes String returns Boolean `Check whether a villain is in the known villain database. Arguments: name: The name of the person to search for. ` inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains) If you want to write comments or notes in a file, you can use a single hash ( # ) and then keep typing. OcellusScript will not execute any code in triple-quotes or after a hash. Comments with a hash extend until the next line in a file. To access documentation for a function, the help function can be called: help inVillainDatabase Where help accepts a single parameter, the callable function with a docstring. If no documentation is found, nothing is returned. Executing a File Thus far, we've defined functions in OcellusScript but haven't quite interacted with them. There are two ways to interact with them: Importing the module into an interactive interpreter environment Defining a main function that will be executed when running a compiled version of a script OcellusScript supports the main function to write a function that executes when you call on a file's executable: import VillainDatabase main args = log (inVillainDatabase Twilight ) When the file above is run after compiling, the main function will be executed. The following is the type signature of the main function: main takes [String?] returns Anything? When the file is executed, it can take in parameters from the command line as parameters to main .","title":"Modules and Main Execution"},{"location":"language/09-modules/#modules-and-main-execution","text":"OcellusScript works on a file-based level and supports creating and importing modules that contain other functions and utilities. When an OcellusScript file is written, it is considered a module in and of itself when the module function is defined. The following example in the file vill.ocls shows how a module is written: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] knownVillains = [(Villain Nightmare Moon true), (Villain Discord true), (Villain Tirek false), (Villain Tempest Shadow false), (Villain Starlight Glimmer false), (Villain Chrysalis false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) - reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains) vill.ocls is a typical OcellusScript file, but because the module function is defined at the top, all functions and types in this file are publicly accessible to other OcellusScript files by importing VillainDatabase . For example, another file called chr.ocls can make use of everything inside this module by using the import function: import VillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase Chrysalis","title":"Modules and Main Execution"},{"location":"language/09-modules/#specific-imports","text":"Importing the entire module may not be necessary and could cost performance. OcellusScript can handle this with specific imports. Again, with chr.ocls , we can manually import the inVillainDatabase function without importing everything else with the only statement: import VillainDatabase only inVillainDatabase foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase Chrysalis Likewise, except will import the entire module except a specific function: import VillainDatabase except knownByReform foundChrysalis takes Nothing returns Boolean foundChrysalis = inVillainDatabase Chrysalis","title":"Specific imports"},{"location":"language/09-modules/#private-functions","text":"Modules expose every function and type in a file and make it publicly accessible, which may not be desired. To mitigate this, adding the keyword private in front of a function definition will make sure that the function does not get imported when the module is imported. Looking back at vill.ocls , we could probably make the knownVillains function private so, say, a villain can't delete their entry from the database: module VillainDatabase where type Reform = Boolean type Name = String datatype KnownVillain = Villain Name Reform knownVillains takes Nothing returns [KnownVillains] private knownVillains = [(Villain Nightmare Moon true), (Villain Discord true), (Villain Tirek false), (Villain Tempest Shadow false), (Villain Starlight Glimmer false), (Villain Chrysalis false)] knownByReform takes Nothing returns [KnownVillains] knownByReform = filter (lambda (Villain _ reform) - reform) knownVillains inVillainDatabase takes String returns Boolean inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains) Note that the private keyword does not need to be in the type signature of the function.","title":"Private functions"},{"location":"language/09-modules/#documentation-strings-and-comments","text":"It's good practice to include documentation with your source code. Documentation often provides information on what a function will do or what a module contains. Documentation strings (docstrings) are denoted with a set of backticks (```) can be inserted between a type signature and a function definition like below: inVillainDatabase takes String returns Boolean `Check whether a villain is in the known villain database. Arguments: name: The name of the person to search for. ` inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains) If you want to write comments or notes in a file, you can use a single hash ( # ) and then keep typing. OcellusScript will not execute any code in triple-quotes or after a hash. Comments with a hash extend until the next line in a file. To access documentation for a function, the help function can be called: help inVillainDatabase Where help accepts a single parameter, the callable function with a docstring. If no documentation is found, nothing is returned.","title":"Documentation Strings and Comments"},{"location":"language/09-modules/#executing-a-file","text":"Thus far, we've defined functions in OcellusScript but haven't quite interacted with them. There are two ways to interact with them: Importing the module into an interactive interpreter environment Defining a main function that will be executed when running a compiled version of a script OcellusScript supports the main function to write a function that executes when you call on a file's executable: import VillainDatabase main args = log (inVillainDatabase Twilight ) When the file above is run after compiling, the main function will be executed. The following is the type signature of the main function: main takes [String?] returns Anything? When the file is executed, it can take in parameters from the command line as parameters to main .","title":"Executing a File"},{"location":"language/10-style/","text":"Stylebook While it isn't functionally necessary to follow the OcellusScript style guidelines, these guidelines can help make your code more readable and easier to understand. Keep Lines Short A line in OcellusScript should be no more than 100 characters in length so that it can be opened and read easily without the need for text-wrapping. Always Include Type Signatures and Docstrings Type signatures and docstrings are completely optional, but should be included to reduce confusion of input and output types, as well as providing sufficient documentation that can be called with help . Use Consistent Indentation OcellusScript files should use space indents with a length of four spaces per indent. Separate Long Lines Longer lines should be separated into smaller lines to make the code easy to read and traverse. The following provides cases where lines should be split. On Conditional Expressions While it is possible to do an in-line ternary operator for a conditional, if the condition evaluation is lengthy, consider putting them on separate lines: doStuff takes Integer returns Integer doStuff x = x % 5 == 1 ? x + 13 : x + 5 On Operators and Lists type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name myList = [(Changeling Ocellus ), (Pony Twilight ), (Zebra Zecora )] On Parameters and Functions inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains) Using \\ Separator If needed, the \\ operator at the end of a line can be used to break up other components like type signatures: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing On Functions Defined with where When possible, functions that use the where syntax to be defined on the next lines should be indented: printLetters takes String returns Nothing printLetters string = for 0 (length string) task where task i = log string[i] Declare Private Functions and Types Before Functions When possible, any custom types, data types, and private functions should go before public functions: module Equestria where type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name private testList = [(Changeling Ocellus ), (Pony Twilight ), (Zebra Zecora )] main args = log Imported!","title":"Stylebook"},{"location":"language/10-style/#stylebook","text":"While it isn't functionally necessary to follow the OcellusScript style guidelines, these guidelines can help make your code more readable and easier to understand.","title":"Stylebook"},{"location":"language/10-style/#keep-lines-short","text":"A line in OcellusScript should be no more than 100 characters in length so that it can be opened and read easily without the need for text-wrapping.","title":"Keep Lines Short"},{"location":"language/10-style/#always-include-type-signatures-and-docstrings","text":"Type signatures and docstrings are completely optional, but should be included to reduce confusion of input and output types, as well as providing sufficient documentation that can be called with help .","title":"Always Include Type Signatures and Docstrings"},{"location":"language/10-style/#use-consistent-indentation","text":"OcellusScript files should use space indents with a length of four spaces per indent.","title":"Use Consistent Indentation"},{"location":"language/10-style/#separate-long-lines","text":"Longer lines should be separated into smaller lines to make the code easy to read and traverse. The following provides cases where lines should be split.","title":"Separate Long Lines"},{"location":"language/10-style/#on-conditional-expressions","text":"While it is possible to do an in-line ternary operator for a conditional, if the condition evaluation is lengthy, consider putting them on separate lines: doStuff takes Integer returns Integer doStuff x = x % 5 == 1 ? x + 13 : x + 5","title":"On Conditional Expressions"},{"location":"language/10-style/#on-operators-and-lists","text":"type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name myList = [(Changeling Ocellus ), (Pony Twilight ), (Zebra Zecora )]","title":"On Operators and Lists"},{"location":"language/10-style/#on-parameters-and-functions","text":"inVillainDatabase name = member name (map (lambda (Villain name _ ) - name) knownVillains)","title":"On Parameters and Functions"},{"location":"language/10-style/#using-separator","text":"If needed, the \\ operator at the end of a line can be used to break up other components like type signatures: for takes Integer and Integer and \\ (Callable takes Anything? returns Anything?) returns Nothing","title":"Using \\ Separator"},{"location":"language/10-style/#on-functions-defined-with-where","text":"When possible, functions that use the where syntax to be defined on the next lines should be indented: printLetters takes String returns Nothing printLetters string = for 0 (length string) task where task i = log string[i]","title":"On Functions Defined with where"},{"location":"language/10-style/#declare-private-functions-and-types-before-functions","text":"When possible, any custom types, data types, and private functions should go before public functions: module Equestria where type Name = String datatype Equestrian = Pony Name or Changeling Name or Dragon Name or Yak Name or Zebra Name private testList = [(Changeling Ocellus ), (Pony Twilight ), (Zebra Zecora )] main args = log Imported!","title":"Declare Private Functions and Types Before Functions"},{"location":"language/11-spec/","text":"Specification The following page is the specification for the OcellusScript language and contains technical information such as lexical elements, program structure, and parsing grammars. Developers using OcellusScript don't need to be too concerned with the specification, but this document is useful for those wishing to write an implementation of the OcellusScript specification, either as a compiler/interpreter for OcellusScript or or as a new language that stems from this spec. Lexical Elements During the tokenization process, OcellusScript will create tokens of the following types: Keyword refers to any of the primary keywords such as types, statements, and values. Identifier refers to a group of uppercase and lowercase letters. StringConstant refers to a string containing valid Unicode characters, excluding double quotes (unless escaped). DocstringConstant refers to a documentation string containing valid Unicode characters that start and end with a back tick (`). CommentConstant refers to a comment containing valid Unicode characters that start with the hash symbol ( # ) and end with a newline character ( \\n ). Symbol refers to any non-alphanumeric characters. IntConstant refers to any integers that do not contain a decimal point. FloatConstant refers to a number that contains a single decimal point. LineReturn refers to a newline character ( \\n ). Below are the lists containing valid keywords, symbols, operators, etc. Type Classified Elements Keyword Character , String , Integer , Boolean , Float , Callable , Anything , Nothing , Error , import , module , where , takes , returns , log , only , except , warn , true , false , type , datatype , private , and , or , not Symbol , , , , ? , [ , ] , ( , ) , - , = , + , * , / , % , \\ , ! , : , # Notes on Lexical Elements CommentConstant is not required to be listed or parsed and can be removed, if necessary. Grammar Structure OcellusScript uses the following grammar set to define functions, expressions, types, etc. when parsing a list of tokens. Grammars with a pipe character ( | ) indicate an 'or' option, grammars with ? will mean optional, and grammars with * will mean a group with zero or more of that particular group. Modules Grammar module := (importStatement)* (module Identifier where)? (fnDef | dataDef | typeDef)* importStatement := import Identifier ((except | only) Identifier (, Identifier)*)? Module Names In cases where there isn't a module statement in the file or script, a random name is assigned and the module is marked as not importable. Otherwise, the module's name will be assigned from the module statement and will be marked as importable. Import Statements When import statements are parsed, the import names in the abstract syntax tree will be represented in three ways: Module.* , when importing the entire module Module.specific , when importing specific from Module Module!specific , when importing the entire module except for specific Custom Types and Datatypes Grammar dataDef := datatype Identifier = dataStructDef (or dataStructDef)* dataStructDef := (Identifier (Identifier | Keyword)*) typeDef := type Identifier = Keyword Identifiers in Datatypes and Custom Types OcellusScript requires that the identifiers used to define custom datatypes and types be written in PascalCase to prevent possible confusion with other functions. Functions Grammar fnDef := (fnSignature)? (Docstring)? fnBody (fnBody)* fnSignature := Identifier takes (fnSignatureType)* returns fnSignatureType fnSignatureType := [Identifier | Keyword] | Identifier|Keyword(?)? | (fnSignature) fnBody := Identifier (fnParam)* = (fnResult) fnParam := Identifier | fnLikeData | fnWithCons fnLikeData := (Identifier (Identifier | Keyword | IntConstant | StringConstant)*) fnWithCons := (Identifier : Identifier (: Identifier)*) fnResult := expression* Expressions Grammar expression := boolExpr | expression boolExpr := equExpr (and | or) equExpr | not equExpr | equExpr equExpr := lowIneqExpr ((! | =)=) lowIneqExpr | lowIneqExpr lowIneqExpr := highIneqExpr (( | )=) highIneqExpr | highIneqExpr highIneqExpr := addExpr ( | ) addExpr | addExpr addExpr := multExpr (+ | -) multExpr | multExpr multExpr := term (* | / | %) term | term term := (expression) | Identifier | StringConstant | IntConstant | keyConst | FloatConstant | list keyConst := true | false | Anything | Nothing list := [term (, term)*] Syntax Tree The following provides the overall structure of what the abstract syntax tree looks like. Modules { module : { name : Example , importable : true , depends : [ Hive.* ], types : {}, datatypes : {}, functions : [] } } Custom Types type : { name : Example , shadows : Boolean } Custom Datatypes datatype : { name : Example , structures : [ ( Example1 String Int ) ] } Functions function : { name : exampleFn , signature : {}, docstring : , body : [] } Function Signature signature : { parameter_types : [ Example ], return : [ Example ] } Function Body body : [ { params : [ example ], result : {} } ] Expression expression : { operative_expression : { operation : null , left : {}, right : {} } } All expressions with operators follow the same basic pattern as operative_expression , but use different keys: boolean_expression equality_expression low_inequal_expression high_inequal_expression additive_expression multiplicative_expression The operation is then set in the operation key if there is an operation present. If nothing is present on either side of the tree's children, \"Nothing\" is put in place of that particular child. Term { identifier : Example } identifier can be replaced with the appropriate term type that matches the value of the type. See below for information on lists as pairs. List Pair list_constant : { head : {}, tail : {} }","title":"Specification"},{"location":"language/11-spec/#specification","text":"The following page is the specification for the OcellusScript language and contains technical information such as lexical elements, program structure, and parsing grammars. Developers using OcellusScript don't need to be too concerned with the specification, but this document is useful for those wishing to write an implementation of the OcellusScript specification, either as a compiler/interpreter for OcellusScript or or as a new language that stems from this spec.","title":"Specification"},{"location":"language/11-spec/#lexical-elements","text":"During the tokenization process, OcellusScript will create tokens of the following types: Keyword refers to any of the primary keywords such as types, statements, and values. Identifier refers to a group of uppercase and lowercase letters. StringConstant refers to a string containing valid Unicode characters, excluding double quotes (unless escaped). DocstringConstant refers to a documentation string containing valid Unicode characters that start and end with a back tick (`). CommentConstant refers to a comment containing valid Unicode characters that start with the hash symbol ( # ) and end with a newline character ( \\n ). Symbol refers to any non-alphanumeric characters. IntConstant refers to any integers that do not contain a decimal point. FloatConstant refers to a number that contains a single decimal point. LineReturn refers to a newline character ( \\n ). Below are the lists containing valid keywords, symbols, operators, etc. Type Classified Elements Keyword Character , String , Integer , Boolean , Float , Callable , Anything , Nothing , Error , import , module , where , takes , returns , log , only , except , warn , true , false , type , datatype , private , and , or , not Symbol , , , , ? , [ , ] , ( , ) , - , = , + , * , / , % , \\ , ! , : , #","title":"Lexical Elements"},{"location":"language/11-spec/#notes-on-lexical-elements","text":"CommentConstant is not required to be listed or parsed and can be removed, if necessary.","title":"Notes on Lexical Elements"},{"location":"language/11-spec/#grammar-structure","text":"OcellusScript uses the following grammar set to define functions, expressions, types, etc. when parsing a list of tokens. Grammars with a pipe character ( | ) indicate an 'or' option, grammars with ? will mean optional, and grammars with * will mean a group with zero or more of that particular group.","title":"Grammar Structure"},{"location":"language/11-spec/#modules","text":"Grammar module := (importStatement)* (module Identifier where)? (fnDef | dataDef | typeDef)* importStatement := import Identifier ((except | only) Identifier (, Identifier)*)?","title":"Modules"},{"location":"language/11-spec/#module-names","text":"In cases where there isn't a module statement in the file or script, a random name is assigned and the module is marked as not importable. Otherwise, the module's name will be assigned from the module statement and will be marked as importable.","title":"Module Names"},{"location":"language/11-spec/#import-statements","text":"When import statements are parsed, the import names in the abstract syntax tree will be represented in three ways: Module.* , when importing the entire module Module.specific , when importing specific from Module Module!specific , when importing the entire module except for specific","title":"Import Statements"},{"location":"language/11-spec/#custom-types-and-datatypes","text":"Grammar dataDef := datatype Identifier = dataStructDef (or dataStructDef)* dataStructDef := (Identifier (Identifier | Keyword)*) typeDef := type Identifier = Keyword","title":"Custom Types and Datatypes"},{"location":"language/11-spec/#identifiers-in-datatypes-and-custom-types","text":"OcellusScript requires that the identifiers used to define custom datatypes and types be written in PascalCase to prevent possible confusion with other functions.","title":"Identifiers in Datatypes and Custom Types"},{"location":"language/11-spec/#functions","text":"Grammar fnDef := (fnSignature)? (Docstring)? fnBody (fnBody)* fnSignature := Identifier takes (fnSignatureType)* returns fnSignatureType fnSignatureType := [Identifier | Keyword] | Identifier|Keyword(?)? | (fnSignature) fnBody := Identifier (fnParam)* = (fnResult) fnParam := Identifier | fnLikeData | fnWithCons fnLikeData := (Identifier (Identifier | Keyword | IntConstant | StringConstant)*) fnWithCons := (Identifier : Identifier (: Identifier)*) fnResult := expression*","title":"Functions"},{"location":"language/11-spec/#expressions","text":"Grammar expression := boolExpr | expression boolExpr := equExpr (and | or) equExpr | not equExpr | equExpr equExpr := lowIneqExpr ((! | =)=) lowIneqExpr | lowIneqExpr lowIneqExpr := highIneqExpr (( | )=) highIneqExpr | highIneqExpr highIneqExpr := addExpr ( | ) addExpr | addExpr addExpr := multExpr (+ | -) multExpr | multExpr multExpr := term (* | / | %) term | term term := (expression) | Identifier | StringConstant | IntConstant | keyConst | FloatConstant | list keyConst := true | false | Anything | Nothing list := [term (, term)*]","title":"Expressions"},{"location":"language/11-spec/#syntax-tree","text":"The following provides the overall structure of what the abstract syntax tree looks like.","title":"Syntax Tree"},{"location":"language/11-spec/#modules_1","text":"{ module : { name : Example , importable : true , depends : [ Hive.* ], types : {}, datatypes : {}, functions : [] } }","title":"Modules"},{"location":"language/11-spec/#custom-types","text":"type : { name : Example , shadows : Boolean }","title":"Custom Types"},{"location":"language/11-spec/#custom-datatypes","text":"datatype : { name : Example , structures : [ ( Example1 String Int ) ] }","title":"Custom Datatypes"},{"location":"language/11-spec/#functions_1","text":"function : { name : exampleFn , signature : {}, docstring : , body : [] }","title":"Functions"},{"location":"language/11-spec/#function-signature","text":"signature : { parameter_types : [ Example ], return : [ Example ] }","title":"Function Signature"},{"location":"language/11-spec/#function-body","text":"body : [ { params : [ example ], result : {} } ]","title":"Function Body"},{"location":"language/11-spec/#expression","text":"expression : { operative_expression : { operation : null , left : {}, right : {} } } All expressions with operators follow the same basic pattern as operative_expression , but use different keys: boolean_expression equality_expression low_inequal_expression high_inequal_expression additive_expression multiplicative_expression The operation is then set in the operation key if there is an operation present. If nothing is present on either side of the tree's children, \"Nothing\" is put in place of that particular child.","title":"Expression"},{"location":"language/11-spec/#term","text":"{ identifier : Example } identifier can be replaced with the appropriate term type that matches the value of the type. See below for information on lists as pairs.","title":"Term"},{"location":"language/11-spec/#list-pair","text":"list_constant : { head : {}, tail : {} }","title":"List Pair"},{"location":"language/12-hive/","text":"The Hive Module The Hive module is a standard library module that can be imported into OcellusScript scripts and modules with the import statement. The Hive module contains several useful functions, datatypes, and types. This document is incomplete This document will be updated as more utilities are written into the Hive module. List Utilities length length takes [Anything] returns Integer Get the length of a list. Arguments list: The list to gather the length of. Returns : Integer value containing the length of the list, or 0 if the list is empty. Example length [ JavaScript , Python , CSS ] # 3 atPosition atPosition takes [Anything] and Integer returns Anything Grab an item from the list at a specified position. Arguments list: The list to iterate through position: The index of the item to return, if possible. Returns : The item at the specified position, or Nothing. Example atPosition [ JS , PY , CSS ] 2 # CSS member member takes Anything and [Anything] returns Boolean Determine whether an item is a member of a specified list. Arguments item: The item to search for in the list list: The list to search for the member Returns : Boolean value indicating whether the item is in the list. Example member Cheese [ Bun , Patty , Cheese , OtherBun ] # true map map takes (Callable takes Anything returns Anything) and [Anything]\\ returns [Anything] Create a list with a function applied to a set of elements. Arguments fn: The function to apply to each element list: The list to apply the function to Returns : A list with elements applied by the function Example allPlusOne = map (lambda x - x + 1) [1, 2, 3] # [2, 3, 4] filter filter takes (Callable takes Anything returns Boolean) and [Anything]\\ returns [Anything] Create a list given a specific condition. Arguments fn: The function to determine what items are inserted into the list list: The list to filter Returns : A list filtered by the function Example evens = filter (lambda x - x % 2 == 0) [1, 2, 3, 4] # [2, 4] reduce reduce takes (Callable takes Anything and Anything returns Anything)\\ and [Anything] and Anything\\ returns Anything Combine a list into a single value. Example plusTimesThree = reduce (lambda x, y - (x + y) * 3) [1, 2, 3] 0 # 54 Arguments fn: The function to determine how values are combined in the list list: The list to reduce into a single value value: The starting value Returns : A single value from all of the combined values Iterators for for takes Integer and Integer (Callable takes Anything? returns Anything?)\\ returns Nothing Perform a task over a range. Arguments start: The starting iteration value. end: The ending iteration value. task: The task to perform on each iteration. Example countToTen = for 1 4 task where task i = log i # 1 # 2 # 3 # 4","title":"The Hive Module"},{"location":"language/12-hive/#the-hive-module","text":"The Hive module is a standard library module that can be imported into OcellusScript scripts and modules with the import statement. The Hive module contains several useful functions, datatypes, and types. This document is incomplete This document will be updated as more utilities are written into the Hive module.","title":"The Hive Module"},{"location":"language/12-hive/#list-utilities","text":"","title":"List Utilities"},{"location":"language/12-hive/#length","text":"length takes [Anything] returns Integer Get the length of a list. Arguments list: The list to gather the length of. Returns : Integer value containing the length of the list, or 0 if the list is empty. Example length [ JavaScript , Python , CSS ] # 3","title":"length"},{"location":"language/12-hive/#atposition","text":"atPosition takes [Anything] and Integer returns Anything Grab an item from the list at a specified position. Arguments list: The list to iterate through position: The index of the item to return, if possible. Returns : The item at the specified position, or Nothing. Example atPosition [ JS , PY , CSS ] 2 # CSS","title":"atPosition"},{"location":"language/12-hive/#member","text":"member takes Anything and [Anything] returns Boolean Determine whether an item is a member of a specified list. Arguments item: The item to search for in the list list: The list to search for the member Returns : Boolean value indicating whether the item is in the list. Example member Cheese [ Bun , Patty , Cheese , OtherBun ] # true","title":"member"},{"location":"language/12-hive/#map","text":"map takes (Callable takes Anything returns Anything) and [Anything]\\ returns [Anything] Create a list with a function applied to a set of elements. Arguments fn: The function to apply to each element list: The list to apply the function to Returns : A list with elements applied by the function Example allPlusOne = map (lambda x - x + 1) [1, 2, 3] # [2, 3, 4]","title":"map"},{"location":"language/12-hive/#filter","text":"filter takes (Callable takes Anything returns Boolean) and [Anything]\\ returns [Anything] Create a list given a specific condition. Arguments fn: The function to determine what items are inserted into the list list: The list to filter Returns : A list filtered by the function Example evens = filter (lambda x - x % 2 == 0) [1, 2, 3, 4] # [2, 4]","title":"filter"},{"location":"language/12-hive/#reduce","text":"reduce takes (Callable takes Anything and Anything returns Anything)\\ and [Anything] and Anything\\ returns Anything Combine a list into a single value. Example plusTimesThree = reduce (lambda x, y - (x + y) * 3) [1, 2, 3] 0 # 54 Arguments fn: The function to determine how values are combined in the list list: The list to reduce into a single value value: The starting value Returns : A single value from all of the combined values","title":"reduce"},{"location":"language/12-hive/#iterators","text":"","title":"Iterators"},{"location":"language/12-hive/#for","text":"for takes Integer and Integer (Callable takes Anything? returns Anything?)\\ returns Nothing Perform a task over a range. Arguments start: The starting iteration value. end: The ending iteration value. task: The task to perform on each iteration. Example countToTen = for 1 4 task where task i = log i # 1 # 2 # 3 # 4","title":"for"}]}